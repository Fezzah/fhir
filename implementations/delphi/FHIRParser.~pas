unit FHIRParser;

interface

uses
  SysUtils, Classes, ActiveX, StringSupport, DateSupport, IdSoapMsXml, FHIRParserBase, FHIRBase, FHIRResources, MsXmlParser;

Type
  TFHIRXmlParser = class (TFHIRXmlParserBase)
  Protected
    function ParseExtension(element : IXmlDomElement) : TExtension;
    function ParseConstraintElement(element : IXmlDomElement) : TConstraintElement;
    function ParseConstraintElementMapping(element : IXmlDomElement) : TConstraintElementMapping;
    function ParseConstraintElementAggregation(element : IXmlDomElement) : TConstraintElementAggregation;
    function ParseConstraintElementValue(element : IXmlDomElement) : TConstraintElementValue;
    function ParseConstraint(element : IXmlDomElement) : TConstraint;
    function ParseNarrativeImage(element : IXmlDomElement) : TNarrativeImage;
    function ParseNarrativeMap(element : IXmlDomElement) : TNarrativeMap;
    function ParseNarrative(element : IXmlDomElement) : TNarrative;
    function ParseCoding(element : IXmlDomElement) : TCoding;
    function ParseInterval_Quantity(element : IXmlDomElement) : TInterval_Quantity;
    function ParseInterval_DateTime(element : IXmlDomElement) : TInterval_DateTime;
    function ParseInterval_Date(element : IXmlDomElement) : TInterval_Date;
    function ParseQuantity(element : IXmlDomElement) : TQuantity;
    function ParseChoiceValue(element : IXmlDomElement) : TChoiceValue;
    function ParseChoice(element : IXmlDomElement) : TChoice;
    function ParseAttachment(element : IXmlDomElement) : TAttachment;
    function ParseRatio(element : IXmlDomElement) : TRatio;
    function ParseCodeableConceptCoding(element : IXmlDomElement) : TCodeableConceptCoding;
    function ParseCodeableConcept(element : IXmlDomElement) : TCodeableConcept;
    function ParseIdentifier(element : IXmlDomElement) : TIdentifier;
    function ParseScheduleRepeat(element : IXmlDomElement) : TScheduleRepeat;
    function ParseSchedule(element : IXmlDomElement) : TSchedule;
    function ParseContact(element : IXmlDomElement) : TContact;
    function ParseAddressPart(element : IXmlDomElement) : TAddressPart;
    function ParseAddress(element : IXmlDomElement) : TAddress;
    function ParseHumanNamePart(element : IXmlDomElement) : THumanNamePart;
    function ParseHumanName(element : IXmlDomElement) : THumanName;
    function ParseHumanId(element : IXmlDomElement) : THumanId;
    function ParseConformancePublisher(element : IXmlDomElement) : TConformancePublisher;
    function ParseConformanceSoftware(element : IXmlDomElement) : TConformanceSoftware;
    function ParseConformanceOperation(element : IXmlDomElement) : TConformanceOperation;
    function ParseConformanceOperationTransaction(element : IXmlDomElement) : TConformanceOperationTransaction;
    function ParseConformanceOperationSearch(element : IXmlDomElement) : TConformanceOperationSearch;
    function ParseConformanceOperationCreate(element : IXmlDomElement) : TConformanceOperationCreate;
    function ParseConformance(element : IXmlDomElement) : TConformance;
    function ParseDocumentAuthor(element : IXmlDomElement) : TDocumentAuthor;
    function ParseDocumentAttestor(element : IXmlDomElement) : TDocumentAttestor;
    function ParseDocumentSection(element : IXmlDomElement) : TDocumentSection;
    function ParseDocumentSectionAuthor(element : IXmlDomElement) : TDocumentSectionAuthor;
    function ParseDocument(element : IXmlDomElement) : TDocument;
    function ParseMessageResponse(element : IXmlDomElement) : TMessageResponse;
    function ParseMessage(element : IXmlDomElement) : TMessage;
    function ParseMessageConformancePublisher(element : IXmlDomElement) : TMessageConformancePublisher;
    function ParseMessageConformanceSoftware(element : IXmlDomElement) : TMessageConformanceSoftware;
    function ParseMessageConformanceEvent(element : IXmlDomElement) : TMessageConformanceEvent;
    function ParseMessageConformanceEventRequest(element : IXmlDomElement) : TMessageConformanceEventRequest;
    function ParseMessageConformanceEventResponse(element : IXmlDomElement) : TMessageConformanceEventResponse;
    function ParseMessageConformance(element : IXmlDomElement) : TMessageConformance;
    function ParseAgent(element : IXmlDomElement) : TAgent;
    function ParseAnimalRelatedEntity(element : IXmlDomElement) : TAnimalRelatedEntity;
    function ParseAnimal(element : IXmlDomElement) : TAnimal;
    function ParsePrescriptionDispense(element : IXmlDomElement) : TPrescriptionDispense;
    function ParsePrescriptionMedicine(element : IXmlDomElement) : TPrescriptionMedicine;
    function ParsePrescriptionMedicineActiveIngredient(element : IXmlDomElement) : TPrescriptionMedicineActiveIngredient;
    function ParsePrescriptionMedicineInactiveIngredient(element : IXmlDomElement) : TPrescriptionMedicineInactiveIngredient;
    function ParsePrescriptionAdministrationRequest(element : IXmlDomElement) : TPrescriptionAdministrationRequest;
    function ParsePrescriptionAdministrationRequestDosageInstruction(element : IXmlDomElement) : TPrescriptionAdministrationRequestDosageInstruction;
    function ParsePrescription(element : IXmlDomElement) : TPrescription;
    function ParsePatient(element : IXmlDomElement) : TPatient;
    function ParseOrganizationName(element : IXmlDomElement) : TOrganizationName;
    function ParseOrganizationAccreditation(element : IXmlDomElement) : TOrganizationAccreditation;
    function ParseOrganizationRelatedOrganization(element : IXmlDomElement) : TOrganizationRelatedOrganization;
    function ParseOrganization(element : IXmlDomElement) : TOrganization;
    function ParseDocumentConformancePublisher(element : IXmlDomElement) : TDocumentConformancePublisher;
    function ParseDocumentConformanceSoftware(element : IXmlDomElement) : TDocumentConformanceSoftware;
    function ParseDocumentConformanceDocument(element : IXmlDomElement) : TDocumentConformanceDocument;
    function ParseDocumentConformance(element : IXmlDomElement) : TDocumentConformance;
    function ParseLabReportRequestDetail(element : IXmlDomElement) : TLabReportRequestDetail;
    function ParseLabReportResultGroup(element : IXmlDomElement) : TLabReportResultGroup;
    function ParseLabReportResultGroupResult(element : IXmlDomElement) : TLabReportResultGroupResult;
    function ParseLabReportResultGroupResultReferenceRange(element : IXmlDomElement) : TLabReportResultGroupResultReferenceRange;
    function ParseLabReport(element : IXmlDomElement) : TLabReport;
    function ParsePersonQualification(element : IXmlDomElement) : TPersonQualification;
    function ParsePersonLanguage(element : IXmlDomElement) : TPersonLanguage;
    function ParsePersonRelatedPerson(element : IXmlDomElement) : TPersonRelatedPerson;
    function ParsePerson(element : IXmlDomElement) : TPerson;
    Function ParseResource(element : IxmlDomElement) : TFHIRResource; override;
End;


implementation

{ TFHIRXmlParser }

function TFHIRXmlParser.ParseExtension(element : IXmlDomElement) : TExtension;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TExtension.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'definition') then
        result.definition := child.text
      else if (child.nodeName = 'ref') then
        result.ref := child.text
      else if (child.nodeName = 'state') then
        result.state := TExtensionState(ParseEnum(CODES_TExtensionState, child.text))
      else if (child.nodeName = 'valueSid') then
        result.value := ParseSid(child)
      else if (child.nodeName = 'valueDateTime') then
        result.value := ParseDateTime(child)
      else if (child.nodeName = 'valueInteger') then
        result.value := ParseInteger(child)
      else if (child.nodeName = 'valueCode') then
        result.value := ParseCode(child)
      else if (child.nodeName = 'valueDate') then
        result.value := ParseDate(child)
      else if (child.nodeName = 'valueDecimal') then
        result.value := ParseDecimal(child)
      else if (child.nodeName = 'valueUri') then
        result.value := ParseUri(child)
      else if (child.nodeName = 'valueId') then
        result.value := ParseId(child)
      else if (child.nodeName = 'valueBase64Binary') then
        result.value := ParseBase64Binary(child)
      else if (child.nodeName = 'valueOid') then
        result.value := ParseOid(child)
      else if (child.nodeName = 'valueString') then
        result.value := ParseString(child)
      else if (child.nodeName = 'valueBoolean') then
        result.value := ParseBoolean(child)
      else if (child.nodeName = 'valueUuid') then
        result.value := ParseUuid(child)
      else if (child.nodeName = 'valueInstant') then
        result.value := ParseInstant(child)
      else if (child.nodeName = 'valueCoding') then
        result.value := ParseCoding(child)
      else if (child.nodeName = 'valueInterval_Quantity') then
        result.value := ParseInterval_Quantity(child)
      else if (child.nodeName = 'valueInterval_DateTime') then
        result.value := ParseInterval_DateTime(child)
      else if (child.nodeName = 'valueInterval_Date') then
        result.value := ParseInterval_Date(child)
      else if (child.nodeName = 'valueQuantity') then
        result.value := ParseQuantity(child)
      else if (child.nodeName = 'valueChoice') then
        result.value := ParseChoice(child)
      else if (child.nodeName = 'valueAttachment') then
        result.value := ParseAttachment(child)
      else if (child.nodeName = 'valueRatio') then
        result.value := ParseRatio(child)
      else if (child.nodeName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child)
      else if (child.nodeName = 'valueIdentifier') then
        result.value := ParseIdentifier(child)
      else if (child.nodeName = 'valueSchedule') then
        result.value := ParseSchedule(child)
      else if (child.nodeName = 'valueContact') then
        result.value := ParseContact(child)
      else if (child.nodeName = 'valueAddress') then
        result.value := ParseAddress(child)
      else if (child.nodeName = 'valueHumanName') then
        result.value := ParseHumanName(child)
      else if (child.nodeName = 'valueHumanId') then
        result.value := ParseHumanId(child)
      else if (child.nodeName = 'extensions') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'extension') Then
            result.Extension.Add(ParseExtension(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConstraintElement(element : IXmlDomElement) : TConstraintElement;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TConstraintElement.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'path') then
        result.path := child.text
      else if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'purpose') then
        result.purpose := child.text
      else if (child.nodeName = 'min') then
        result.min := StringToInteger32(child.text)
      else if (child.nodeName = 'max') then
        result.max := child.text
      else if (child.nodeName = 'type') then
        result.type_ := child.text
      else if (child.nodeName = 'conformance') then
        result.conformance := TConformanceType(ParseEnum(CODES_TConformanceType, child.text))
      else if (child.nodeName = 'condition') then
        result.condition := child.text
      else if (child.nodeName = 'mustSupport') then
        result.mustSupport := StringToBoolean(child.text)
      else if (child.nodeName = 'mustUnderstand') then
        result.mustUnderstand := StringToBoolean(child.text)
      else if (child.nodeName = 'definition') then
        result.definition := child.text
      else if (child.nodeName = 'mappings') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'mapping') Then
            result.Mapping.Add(ParseConstraintElementMapping(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'aggregation') then
        result.aggregation := ParseConstraintElementAggregation(child)
      else if (child.nodeName = 'valueSet') then
        result.valueSet := child.text
      else if (child.nodeName = 'values') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'value') Then
            result.Value.Add(ParseConstraintElementValue(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConstraintElementMapping(element : IXmlDomElement) : TConstraintElementMapping;
var
  child : IXMLDOMElement;
begin
  result := TConstraintElementMapping.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'target') then
        result.target := child.text
      else if (child.nodeName = 'map') then
        result.map := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConstraintElementAggregation(element : IXmlDomElement) : TConstraintElementAggregation;
var
  child : IXMLDOMElement;
begin
  result := TConstraintElementAggregation.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'aggregated') then
        result.aggregated := StringToBoolean(child.text)
      else if (child.nodeName = 'name') then
        result.name := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConstraintElementValue(element : IXmlDomElement) : TConstraintElementValue;
var
  child : IXMLDOMElement;
begin
  result := TConstraintElementValue.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'Sid') then
        result.value := ParseSid(child)
      else if (child.nodeName = 'DateTime') then
        result.value := ParseDateTime(child)
      else if (child.nodeName = 'Integer') then
        result.value := ParseInteger(child)
      else if (child.nodeName = 'Code') then
        result.value := ParseCode(child)
      else if (child.nodeName = 'Date') then
        result.value := ParseDate(child)
      else if (child.nodeName = 'Decimal') then
        result.value := ParseDecimal(child)
      else if (child.nodeName = 'Uri') then
        result.value := ParseUri(child)
      else if (child.nodeName = 'Id') then
        result.value := ParseId(child)
      else if (child.nodeName = 'Base64Binary') then
        result.value := ParseBase64Binary(child)
      else if (child.nodeName = 'Oid') then
        result.value := ParseOid(child)
      else if (child.nodeName = 'String') then
        result.value := ParseString(child)
      else if (child.nodeName = 'Boolean') then
        result.value := ParseBoolean(child)
      else if (child.nodeName = 'Uuid') then
        result.value := ParseUuid(child)
      else if (child.nodeName = 'Instant') then
        result.value := ParseInstant(child)
      else if (child.nodeName = 'Coding') then
        result.value := ParseCoding(child)
      else if (child.nodeName = 'Interval_Quantity') then
        result.value := ParseInterval_Quantity(child)
      else if (child.nodeName = 'Interval_DateTime') then
        result.value := ParseInterval_DateTime(child)
      else if (child.nodeName = 'Interval_Date') then
        result.value := ParseInterval_Date(child)
      else if (child.nodeName = 'Quantity') then
        result.value := ParseQuantity(child)
      else if (child.nodeName = 'Choice') then
        result.value := ParseChoice(child)
      else if (child.nodeName = 'Attachment') then
        result.value := ParseAttachment(child)
      else if (child.nodeName = 'Ratio') then
        result.value := ParseRatio(child)
      else if (child.nodeName = 'CodeableConcept') then
        result.value := ParseCodeableConcept(child)
      else if (child.nodeName = 'Identifier') then
        result.value := ParseIdentifier(child)
      else if (child.nodeName = 'Schedule') then
        result.value := ParseSchedule(child)
      else if (child.nodeName = 'Contact') then
        result.value := ParseContact(child)
      else if (child.nodeName = 'Address') then
        result.value := ParseAddress(child)
      else if (child.nodeName = 'HumanName') then
        result.value := ParseHumanName(child)
      else if (child.nodeName = 'HumanId') then
        result.value := ParseHumanId(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConstraint(element : IXmlDomElement) : TConstraint;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TConstraint.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'type') then
        result.type_ := child.text
      else if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'purpose') then
        result.purpose := child.text
      else if (child.nodeName = 'elements') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'element') Then
            result.Element.Add(ParseConstraintElement(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrativeImage(element : IXmlDomElement) : TNarrativeImage;
var
  child : IXMLDOMElement;
begin
  result := TNarrativeImage.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'mimeType') then
        result.mimeType := child.text
      else if (child.nodeName = 'content') then
        result.content := ParseAdvBuffer(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrativeMap(element : IXmlDomElement) : TNarrativeMap;
var
  child : IXMLDOMElement;
begin
  result := TNarrativeMap.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'text') then
        result.text := child.text
      else if (child.nodeName = 'data') then
        result.data := child.text
      else if (child.nodeName = 'source') then
        result.source := TNarrativeMapSource(ParseEnum(CODES_TNarrativeMapSource, child.text))
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseNarrative(element : IXmlDomElement) : TNarrative;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TNarrative.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'status') then
        result.status := TNarrativeStatus(ParseEnum(CODES_TNarrativeStatus, child.text))
      else if (child.nodeName = 'html') then
        result.html := child.text
      else if (child.nodeName = 'images') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'image') Then
            result.Image.Add(ParseNarrativeImage(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'maps') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'map') Then
            result.Map.Add(ParseNarrativeMap(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCoding(element : IXmlDomElement) : TCoding;
var
  child : IXMLDOMElement;
begin
  result := TCoding.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'system') then
        result.system := child.text
      else if (child.nodeName = 'display') then
        result.display := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInterval_Quantity(element : IXmlDomElement) : TInterval_Quantity;
var
  child : IXMLDOMElement;
begin
  result := TInterval_Quantity.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'low') then
        result.low := ParseQuantity(child)
      else if (child.nodeName = 'high') then
        result.high := ParseQuantity(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInterval_DateTime(element : IXmlDomElement) : TInterval_DateTime;
var
  child : IXMLDOMElement;
begin
  result := TInterval_DateTime.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'low') then
        result.low := child.text
      else if (child.nodeName = 'high') then
        result.high := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseInterval_Date(element : IXmlDomElement) : TInterval_Date;
var
  child : IXMLDOMElement;
begin
  result := TInterval_Date.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'low') then
        result.low := child.text
      else if (child.nodeName = 'high') then
        result.high := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseQuantity(element : IXmlDomElement) : TQuantity;
var
  child : IXMLDOMElement;
begin
  result := TQuantity.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'value') then
        result.value := ParseSmartDecimal(child)
      else if (child.nodeName = 'status') then
        result.status := TQuantityStatus(ParseEnum(CODES_TQuantityStatus, child.text))
      else if (child.nodeName = 'units') then
        result.units := child.text
      else if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'system') then
        result.system := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChoiceValue(element : IXmlDomElement) : TChoiceValue;
var
  child : IXMLDOMElement;
begin
  result := TChoiceValue.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'display') then
        result.display := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseChoice(element : IXmlDomElement) : TChoice;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TChoice.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'values') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'value') Then
            result.Value.Add(ParseChoiceValue(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'isOrdered') then
        result.isOrdered := StringToBoolean(child.text)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAttachment(element : IXmlDomElement) : TAttachment;
var
  child : IXMLDOMElement;
begin
  result := TAttachment.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'mimeType') then
        result.mimeType := child.text
      else if (child.nodeName = 'data') then
        result.data := ParseAdvBuffer(child)
      else if (child.nodeName = 'url') then
        result.url := child.text
      else if (child.nodeName = 'hash') then
        result.hash := ParseAdvBuffer(child)
      else if (child.nodeName = 'lang') then
        result.lang := child.text
      else if (child.nodeName = 'title') then
        result.title := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseRatio(element : IXmlDomElement) : TRatio;
var
  child : IXMLDOMElement;
begin
  result := TRatio.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'numerator') then
        result.numerator := ParseQuantity(child)
      else if (child.nodeName = 'denominator') then
        result.denominator := ParseQuantity(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableConceptCoding(element : IXmlDomElement) : TCodeableConceptCoding;
var
  child : IXMLDOMElement;
begin
  result := TCodeableConceptCoding.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'system') then
        result.system := child.text
      else if (child.nodeName = 'display') then
        result.display := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseCodeableConcept(element : IXmlDomElement) : TCodeableConcept;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TCodeableConcept.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'codings') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'coding') Then
            result.Coding.Add(ParseCodeableConceptCoding(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'primary') then
        result.primary := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseIdentifier(element : IXmlDomElement) : TIdentifier;
var
  child : IXMLDOMElement;
begin
  result := TIdentifier.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'system') then
        result.system := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseScheduleRepeat(element : IXmlDomElement) : TScheduleRepeat;
var
  child : IXMLDOMElement;
begin
  result := TScheduleRepeat.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'frequency') then
        result.frequency := StringToInteger32(child.text)
      else if (child.nodeName = 'when') then
        result.when := TEventTiming(ParseEnum(CODES_TEventTiming, child.text))
      else if (child.nodeName = 'duration') then
        result.duration := ParseQuantity(child)
      else if (child.nodeName = 'count') then
        result.count := StringToInteger32(child.text)
      else if (child.nodeName = 'end') then
        result.end_ := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseSchedule(element : IXmlDomElement) : TSchedule;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TSchedule.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'events') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'event') Then
            result.Event.Add(ParseInterval_dateTime(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'repeat') then
        result.repeat_ := ParseScheduleRepeat(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseContact(element : IXmlDomElement) : TContact;
var
  child : IXMLDOMElement;
begin
  result := TContact.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'system') then
        result.system := TContactSystem(ParseEnum(CODES_TContactSystem, child.text))
      else if (child.nodeName = 'value') then
        result.value := child.text
      else if (child.nodeName = 'use') then
        result.use := TContactUse(ParseEnum(CODES_TContactUse, child.text))
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAddressPart(element : IXmlDomElement) : TAddressPart;
var
  child : IXMLDOMElement;
begin
  result := TAddressPart.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'type') then
        result.type_ := TAddressPartType(ParseEnum(CODES_TAddressPartType, child.text))
      else if (child.nodeName = 'value') then
        result.value := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAddress(element : IXmlDomElement) : TAddress;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TAddress.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'use') then
        result.use := TAddressUse(ParseEnum(CODES_TAddressUse, child.text))
      else if (child.nodeName = 'parts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'part') Then
            result.Part.Add(ParseAddressPart(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanNamePart(element : IXmlDomElement) : THumanNamePart;
var
  child : IXMLDOMElement;
begin
  result := THumanNamePart.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'type') then
        result.type_ := TNamePartType(ParseEnum(CODES_TNamePartType, child.text))
      else if (child.nodeName = 'value') then
        result.value := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanName(element : IXmlDomElement) : THumanName;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := THumanName.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'use') then
        result.use := TNameUse(ParseEnum(CODES_TNameUse, child.text))
      else if (child.nodeName = 'parts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'part') Then
            result.Part.Add(ParseHumanNamePart(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseHumanId(element : IXmlDomElement) : THumanId;
var
  child : IXMLDOMElement;
begin
  result := THumanId.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'type') then
        result.type_ := ParseCoding(child)
      else if (child.nodeName = 'identifier') then
        result.identifier := ParseIdentifier(child)
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else if (child.nodeName = 'assigner') then
        result.assigner := ParseFHIRResourceReference{TOrganization}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformancePublisher(element : IXmlDomElement) : TConformancePublisher;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TConformancePublisher.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceSoftware(element : IXmlDomElement) : TConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TConformanceSoftware.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'version') then
        result.version := child.text
      else if (child.nodeName = 'releaseDate') then
        result.releaseDate := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceOperation(element : IXmlDomElement) : TConformanceOperation;
var
  child : IXMLDOMElement;
begin
  result := TConformanceOperation.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'read') then
        result.read := StringToBoolean(child.text)
      else if (child.nodeName = 'vread') then
        result.vread := StringToBoolean(child.text)
      else if (child.nodeName = 'update') then
        result.update := StringToBoolean(child.text)
      else if (child.nodeName = 'delete') then
        result.delete := StringToBoolean(child.text)
      else if (child.nodeName = 'validate') then
        result.validate := StringToBoolean(child.text)
      else if (child.nodeName = 'history') then
        result.history := StringToBoolean(child.text)
      else if (child.nodeName = 'transaction') then
        result.transaction := ParseConformanceOperationTransaction(child)
      else if (child.nodeName = 'search') then
        result.search := ParseConformanceOperationSearch(child)
      else if (child.nodeName = 'create') then
        result.create_ := ParseConformanceOperationCreate(child)
      else if (child.nodeName = 'updates') then
        result.updates := StringToBoolean(child.text)
      else if (child.nodeName = 'schema') then
        result.schema := StringToBoolean(child.text)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceOperationTransaction(element : IXmlDomElement) : TConformanceOperationTransaction;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TConformanceOperationTransaction.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'names') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'name') Then
            result.Name.Add(child.text)
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceOperationSearch(element : IXmlDomElement) : TConformanceOperationSearch;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TConformanceOperationSearch.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'params') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'param') Then
            result.Param.Add(child.text)
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformanceOperationCreate(element : IXmlDomElement) : TConformanceOperationCreate;
var
  child : IXMLDOMElement;
begin
  result := TConformanceOperationCreate.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseConformance(element : IXmlDomElement) : TConformance;
var
  child : IXMLDOMElement;
begin
  result := TConformance.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'date') then
        result.date := child.text
      else if (child.nodeName = 'publisher') then
        result.publisher := ParseConformancePublisher(child)
      else if (child.nodeName = 'software') then
        result.software := ParseConformanceSoftware(child)
      else if (child.nodeName = 'mode') then
        result.mode := TRestfulConformanceMode(ParseEnum(CODES_TRestfulConformanceMode, child.text))
      else if (child.nodeName = 'resource') then
        result.resource := ParseConstraint(child)
      else if (child.nodeName = 'operation') then
        result.operation := ParseConformanceOperation(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentAuthor(element : IXmlDomElement) : TDocumentAuthor;
var
  child : IXMLDOMElement;
begin
  result := TDocumentAuthor.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'time') then
        result.time := child.text
      else if (child.nodeName = 'party') then
        result.party := ParseFHIRResourceReference{Resource}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentAttestor(element : IXmlDomElement) : TDocumentAttestor;
var
  child : IXMLDOMElement;
begin
  result := TDocumentAttestor.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'mode') then
        result.mode := TDocumentAuthenticationMode(ParseEnum(CODES_TDocumentAuthenticationMode, child.text))
      else if (child.nodeName = 'time') then
        result.time := child.text
      else if (child.nodeName = 'party') then
        result.party := ParseFHIRResourceReference{TPerson}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentSection(element : IXmlDomElement) : TDocumentSection;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TDocumentSection.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'type') then
        result.type_ := ParseCodeableConcept(child)
      else if (child.nodeName = 'instant') then
        result.instant := XMLDateTimeStringToDateTime(child.text)
      else if (child.nodeName = 'author') then
        result.author := ParseDocumentSectionAuthor(child)
      else if (child.nodeName = 'enterer') then
        result.enterer := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'subject') then
        result.subject := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'informant') then
        result.informant := ParseFHIRResourceReference{TPerson}(child)
      else if (child.nodeName = 'content') then
        result.content := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'sections') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'section') Then
            result.Section.Add(ParseDocumentSection(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentSectionAuthor(element : IXmlDomElement) : TDocumentSectionAuthor;
var
  child : IXMLDOMElement;
begin
  result := TDocumentSectionAuthor.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'time') then
        result.time := child.text
      else if (child.nodeName = 'party') then
        result.party := ParseFHIRResourceReference{Resource}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocument(element : IXmlDomElement) : TDocument;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TDocument.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'instant') then
        result.instant := XMLDateTimeStringToDateTime(child.text)
      else if (child.nodeName = 'type') then
        result.type_ := ParseCodeableConcept(child)
      else if (child.nodeName = 'title') then
        result.title := child.text
      else if (child.nodeName = 'setId') then
        result.setId := child.text
      else if (child.nodeName = 'version') then
        result.version := StringToInteger32(child.text)
      else if (child.nodeName = 'replaces') then
        result.replaces := child.text
      else if (child.nodeName = 'subject') then
        result.subject := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'authors') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'author') Then
            result.Author.Add(ParseDocumentAuthor(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'attestors') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'attestor') Then
            result.Attestor.Add(ParseDocumentAttestor(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'recipients') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'recipient') Then
            result.Recipient.Add(ParseFHIRResourceReference{Resource}(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'custodian') then
        result.custodian := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'event') then
        result.event := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'encounter') then
        result.encounter := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'sections') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'section') Then
            result.Section.Add(ParseDocumentSection(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageResponse(element : IXmlDomElement) : TMessageResponse;
var
  child : IXMLDOMElement;
begin
  result := TMessageResponse.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := child.text
      else if (child.nodeName = 'code') then
        result.code := TResponseCode(ParseEnum(CODES_TResponseCode, child.text))
      else if (child.nodeName = 'duplicate') then
        result.duplicate := StringToBoolean(child.text)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessage(element : IXmlDomElement) : TMessage;
var
  child : IXMLDOMElement;
begin
  result := TMessage.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'threadId') then
        result.threadId := child.text
      else if (child.nodeName = 'instant') then
        result.instant := XMLDateTimeStringToDateTime(child.text)
      else if (child.nodeName = 'event') then
        result.event := child.text
      else if (child.nodeName = 'response') then
        result.response := ParseMessageResponse(child)
      else if (child.nodeName = 'source') then
        result.source := ParseFHIRResourceReference{TDevice}(child)
      else if (child.nodeName = 'destination') then
        result.destination := ParseFHIRResourceReference{TDevice}(child)
      else if (child.nodeName = 'enterer') then
        result.enterer := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'author') then
        result.author := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'responsible') then
        result.responsible := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'effective') then
        result.effective := ParseInterval_dateTime(child)
      else if (child.nodeName = 'reason') then
        result.reason := ParseCodeableConcept(child)
      else if (child.nodeName = 'data') then
        result.data := ParseFHIRResourceReference{Resource}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformancePublisher(element : IXmlDomElement) : TMessageConformancePublisher;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TMessageConformancePublisher.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformanceSoftware(element : IXmlDomElement) : TMessageConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TMessageConformanceSoftware.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'version') then
        result.version := child.text
      else if (child.nodeName = 'releaseDate') then
        result.releaseDate := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformanceEvent(element : IXmlDomElement) : TMessageConformanceEvent;
var
  child : IXMLDOMElement;
begin
  result := TMessageConformanceEvent.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'resource') then
        result.resource := child.text
      else if (child.nodeName = 'mode') then
        result.mode := TMessageConformanceEventMode(ParseEnum(CODES_TMessageConformanceEventMode, child.text))
      else if (child.nodeName = 'request') then
        result.request := ParseMessageConformanceEventRequest(child)
      else if (child.nodeName = 'response') then
        result.response := ParseMessageConformanceEventResponse(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformanceEventRequest(element : IXmlDomElement) : TMessageConformanceEventRequest;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TMessageConformanceEventRequest.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'resources') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'resource') Then
            result.Resource.Add(ParseConstraint(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformanceEventResponse(element : IXmlDomElement) : TMessageConformanceEventResponse;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TMessageConformanceEventResponse.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'resources') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'resource') Then
            result.Resource.Add(ParseConstraint(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseMessageConformance(element : IXmlDomElement) : TMessageConformance;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TMessageConformance.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'date') then
        result.date := child.text
      else if (child.nodeName = 'publisher') then
        result.publisher := ParseMessageConformancePublisher(child)
      else if (child.nodeName = 'software') then
        result.software := ParseMessageConformanceSoftware(child)
      else if (child.nodeName = 'events') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'event') Then
            result.Event.Add(ParseMessageConformanceEvent(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAgent(element : IXmlDomElement) : TAgent;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TAgent.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'person') then
        result.person := ParseFHIRResourceReference{TPerson}(child)
      else if (child.nodeName = 'organization') then
        result.organization := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'roles') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'role') Then
            result.Role.Add(ParseCodeableConcept(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAnimalRelatedEntity(element : IXmlDomElement) : TAnimalRelatedEntity;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TAnimalRelatedEntity.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := ParseHumanId(child)
      else if (child.nodeName = 'role') then
        result.role := ParseCodeableConcept(child)
      else if (child.nodeName = 'name') then
        result.name := ParseHumanName(child)
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseAnimal(element : IXmlDomElement) : TAnimal;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TAnimal.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'names') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'name') Then
            result.Name.Add(ParseHumanName(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'dob') then
        result.dob := child.text
      else if (child.nodeName = 'species') then
        result.species := ParseCodeableConcept(child)
      else if (child.nodeName = 'strain') then
        result.strain := ParseCodeableConcept(child)
      else if (child.nodeName = 'gender') then
        result.gender := ParseCodeableConcept(child)
      else if (child.nodeName = 'relatedEntities') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'relatedEntity') Then
            result.RelatedEntity.Add(ParseAnimalRelatedEntity(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionDispense(element : IXmlDomElement) : TPrescriptionDispense;
var
  child : IXMLDOMElement;
begin
  result := TPrescriptionDispense.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'repeats') then
        result.repeats := StringToInteger32(child.text)
      else if (child.nodeName = 'quantity') then
        result.quantity := ParseQuantity(child)
      else if (child.nodeName = 'dispenser') then
        result.dispenser := ParseFHIRResourceReference{Resource}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionMedicine(element : IXmlDomElement) : TPrescriptionMedicine;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPrescriptionMedicine.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'productCode') then
        result.productCode := ParseCoding(child)
      else if (child.nodeName = 'description') then
        result.description := child.text
      else if (child.nodeName = 'activeIngredients') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'activeIngredient') Then
            result.ActiveIngredient.Add(ParsePrescriptionMedicineActiveIngredient(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'inactiveIngredients') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'inactiveIngredient') Then
            result.InactiveIngredient.Add(ParsePrescriptionMedicineInactiveIngredient(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionMedicineActiveIngredient(element : IXmlDomElement) : TPrescriptionMedicineActiveIngredient;
var
  child : IXMLDOMElement;
begin
  result := TPrescriptionMedicineActiveIngredient.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'productCode') then
        result.productCode := ParseCoding(child)
      else if (child.nodeName = 'quantity') then
        result.quantity := ParseRatio(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionMedicineInactiveIngredient(element : IXmlDomElement) : TPrescriptionMedicineInactiveIngredient;
var
  child : IXMLDOMElement;
begin
  result := TPrescriptionMedicineInactiveIngredient.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'productCode') then
        result.productCode := ParseCoding(child)
      else if (child.nodeName = 'quantity') then
        result.quantity := ParseRatio(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionAdministrationRequest(element : IXmlDomElement) : TPrescriptionAdministrationRequest;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPrescriptionAdministrationRequest.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'description') then
        result.description := child.text
      else if (child.nodeName = 'totalPeriodicDosis') then
        result.totalPeriodicDosis := ParseRatio(child)
      else if (child.nodeName = 'start') then
        result.start := child.text
      else if (child.nodeName = 'end') then
        result.end_ := child.text
      else if (child.nodeName = 'duration') then
        result.duration := ParseQuantity(child)
      else if (child.nodeName = 'numberOfAdministrations') then
        result.numberOfAdministrations := StringToInteger32(child.text)
      else if (child.nodeName = 'dosageInstructions') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'dosageInstruction') Then
            result.DosageInstruction.Add(ParsePrescriptionAdministrationRequestDosageInstruction(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescriptionAdministrationRequestDosageInstruction(element : IXmlDomElement) : TPrescriptionAdministrationRequestDosageInstruction;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPrescriptionAdministrationRequestDosageInstruction.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'preconditions') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'precondition') Then
            result.Precondition.Add(ParseCodeableConcept(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'prn') then
        result.prn := TBooleanYesNo(ParseEnum(CODES_TBooleanYesNo, child.text))
      else if (child.nodeName = 'additionalInstructions') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'additionalInstruction') Then
            result.AdditionalInstruction.Add(ParseCodeableConcept(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'route') then
        result.route := ParseCodeableConcept(child)
      else if (child.nodeName = 'doseQuantity') then
        result.dose := ParseQuantity(child)
      else if (child.nodeName = 'doseInterval_Quantity') then
        result.dose := ParseInterval_Quantity(child)
      else if (child.nodeName = 'rate') then
        result.rate := ParseQuantity(child)
      else if (child.nodeName = 'schedules') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'schedule') Then
            result.Schedule.Add(ParseSchedule(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePrescription(element : IXmlDomElement) : TPrescription;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPrescription.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'status') then
        result.status := TPrescriptionStatus(ParseEnum(CODES_TPrescriptionStatus, child.text))
      else if (child.nodeName = 'patient') then
        result.patient := ParseFHIRResourceReference{TPatient}(child)
      else if (child.nodeName = 'prescriber') then
        result.prescriber := ParseFHIRResourceReference{TAgent}(child)
      else if (child.nodeName = 'prescribed') then
        result.prescribed := child.text
      else if (child.nodeName = 'dispense') then
        result.dispense := ParsePrescriptionDispense(child)
      else if (child.nodeName = 'medicine') then
        result.medicine := ParsePrescriptionMedicine(child)
      else if (child.nodeName = 'administrationRequest') then
        result.administrationRequest := ParsePrescriptionAdministrationRequest(child)
      else if (child.nodeName = 'reason') then
        result.reason := ParseCodeableConcept(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePatient(element : IXmlDomElement) : TPatient;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPatient.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'links') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'link') Then
            result.Link_.Add(ParseFHIRResourceReference{TPatient}(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'active') then
        result.active := StringToBoolean(child.text)
      else if (child.nodeName = 'person') then
        result.person := ParseFHIRResourceReference{TPerson}(child)
      else if (child.nodeName = 'animal') then
        result.animal := ParseFHIRResourceReference{TAnimal}(child)
      else if (child.nodeName = 'provider') then
        result.provider := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'diet') then
        result.diet := ParseCodeableConcept(child)
      else if (child.nodeName = 'confidentiality') then
        result.confidentiality := ParseCodeableConcept(child)
      else if (child.nodeName = 'recordLocation') then
        result.recordLocation := ParseCodeableConcept(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationName(element : IXmlDomElement) : TOrganizationName;
var
  child : IXMLDOMElement;
begin
  result := TOrganizationName.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'value') then
        result.value := child.text
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationAccreditation(element : IXmlDomElement) : TOrganizationAccreditation;
var
  child : IXMLDOMElement;
begin
  result := TOrganizationAccreditation.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := ParseIdentifier(child)
      else if (child.nodeName = 'code') then
        result.code := ParseCodeableConcept(child)
      else if (child.nodeName = 'institution') then
        result.institution := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganizationRelatedOrganization(element : IXmlDomElement) : TOrganizationRelatedOrganization;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TOrganizationRelatedOrganization.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := ParseHumanId(child)
      else if (child.nodeName = 'code') then
        result.code := ParseCodeableConcept(child)
      else if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_dateTime(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseOrganization(element : IXmlDomElement) : TOrganization;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TOrganization.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := ParseCodeableConcept(child)
      else if (child.nodeName = 'industryCode') then
        result.industryCode := ParseCodeableConcept(child)
      else if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'names') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'name') Then
            result.Name.Add(ParseOrganizationName(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'accreditations') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'accreditation') Then
            result.Accreditation.Add(ParseOrganizationAccreditation(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'relatedOrganizations') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'relatedOrganization') Then
            result.RelatedOrganization.Add(ParseOrganizationRelatedOrganization(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentConformancePublisher(element : IXmlDomElement) : TDocumentConformancePublisher;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TDocumentConformancePublisher.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentConformanceSoftware(element : IXmlDomElement) : TDocumentConformanceSoftware;
var
  child : IXMLDOMElement;
begin
  result := TDocumentConformanceSoftware.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'version') then
        result.version := child.text
      else if (child.nodeName = 'releaseDate') then
        result.releaseDate := child.text
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentConformanceDocument(element : IXmlDomElement) : TDocumentConformanceDocument;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TDocumentConformanceDocument.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := child.text
      else if (child.nodeName = 'purpose') then
        result.purpose := child.text
      else if (child.nodeName = 'resources') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'resource') Then
            result.Resource.Add(ParseConstraint(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseDocumentConformance(element : IXmlDomElement) : TDocumentConformance;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TDocumentConformance.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'date') then
        result.date := child.text
      else if (child.nodeName = 'publisher') then
        result.publisher := ParseDocumentConformancePublisher(child)
      else if (child.nodeName = 'software') then
        result.software := ParseDocumentConformanceSoftware(child)
      else if (child.nodeName = 'documents') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'document') Then
            result.Document.Add(ParseDocumentConformanceDocument(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLabReportRequestDetail(element : IXmlDomElement) : TLabReportRequestDetail;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TLabReportRequestDetail.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'requestOrderId') then
        result.requestOrderId := ParseIdentifier(child)
      else if (child.nodeName = 'receiverOrderId') then
        result.receiverOrderId := ParseIdentifier(child)
      else if (child.nodeName = 'requestTests') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'requestTest') Then
            result.RequestTest.Add(ParseCodeableConcept(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'requester') then
        result.requester := ParseFHIRResourceReference{Resource}(child)
      else if (child.nodeName = 'clinicalInfo') then
        result.clinicalInfo := ParseFHIRResourceReference{Resource}(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLabReportResultGroup(element : IXmlDomElement) : TLabReportResultGroup;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TLabReportResultGroup.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := ParseCodeableConcept(child)
      else if (child.nodeName = 'specimen') then
        result.specimen := ParseFHIRResourceReference{TSpecimen}(child)
      else if (child.nodeName = 'results') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'result') Then
            result.Result.Add(ParseLabReportResultGroupResult(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLabReportResultGroupResult(element : IXmlDomElement) : TLabReportResultGroupResult;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TLabReportResultGroupResult.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'name') then
        result.name := ParseCodeableConcept(child)
      else if (child.nodeName = 'valueQuantity') then
        result.value := ParseQuantity(child)
      else if (child.nodeName = 'valueCodeableConcept') then
        result.value := ParseCodeableConcept(child)
      else if (child.nodeName = 'valueAttachment') then
        result.value := ParseAttachment(child)
      else if (child.nodeName = 'valueRatio') then
        result.value := ParseRatio(child)
      else if (child.nodeName = 'valueChoice') then
        result.value := ParseChoice(child)
      else if (child.nodeName = 'valueInterval_DateTime') then
        result.value := ParseInterval_DateTime(child)
      else if (child.nodeName = 'valueString') then
        result.value := ParseString(child)
      else if (child.nodeName = 'flag') then
        result.flag := TLabResultFlag(ParseEnum(CODES_TLabResultFlag, child.text))
      else if (child.nodeName = 'status') then
        result.status := TLabReportStatus(ParseEnum(CODES_TLabReportStatus, child.text))
      else if (child.nodeName = 'comments') then
        result.comments := child.text
      else if (child.nodeName = 'referenceRanges') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'referenceRange') Then
            result.ReferenceRange.Add(ParseLabReportResultGroupResultReferenceRange(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLabReportResultGroupResultReferenceRange(element : IXmlDomElement) : TLabReportResultGroupResultReferenceRange;
var
  child : IXMLDOMElement;
begin
  result := TLabReportResultGroupResultReferenceRange.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'meaning') then
        result.meaning := ParseCodeableConcept(child)
      else if (child.nodeName = 'rangeQuantity') then
        result.range := ParseQuantity(child)
      else if (child.nodeName = 'rangeInterval_Quantity') then
        result.range := ParseInterval_Quantity(child)
      else if (child.nodeName = 'rangeString') then
        result.range := ParseString(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseLabReport(element : IXmlDomElement) : TLabReport;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TLabReport.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'status') then
        result.status := TLabReportStatus(ParseEnum(CODES_TLabReportStatus, child.text))
      else if (child.nodeName = 'issued') then
        result.issued := XMLDateTimeStringToDateTime(child.text)
      else if (child.nodeName = 'patient') then
        result.patient := ParseFHIRResourceReference{TPatient}(child)
      else if (child.nodeName = 'admission') then
        result.admission := ParseFHIRResourceReference{TAdmission}(child)
      else if (child.nodeName = 'laboratory') then
        result.laboratory := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'reportId') then
        result.reportId := child.text
      else if (child.nodeName = 'requestDetails') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'requestDetail') Then
            result.RequestDetail.Add(ParseLabReportRequestDetail(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'reportName') then
        result.reportName := ParseCodeableConcept(child)
      else if (child.nodeName = 'service') then
        result.service := ParseCodeableConcept(child)
      else if (child.nodeName = 'diagnosticTime') then
        result.diagnosticTime := child.text
      else if (child.nodeName = 'specimen') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'specimen') Then
            result.Specimen.Add(ParseFHIRResourceReference{TSpecimen}(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'resultGroups') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'resultGroup') Then
            result.ResultGroup.Add(ParseLabReportResultGroup(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'conclusion') then
        result.conclusion := ParseNarrative(child)
      else if (child.nodeName = 'codedDiagnoses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'codedDiagnosis') Then
            result.CodedDiagnosis.Add(ParseCodeableConcept(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'representations') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'representation') Then
            result.Representation.Add(ParseAttachment(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonQualification(element : IXmlDomElement) : TPersonQualification;
var
  child : IXMLDOMElement;
begin
  result := TPersonQualification.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := ParseIdentifier(child)
      else if (child.nodeName = 'code') then
        result.code := ParseCodeableConcept(child)
      else if (child.nodeName = 'institution') then
        result.institution := ParseFHIRResourceReference{TOrganization}(child)
      else if (child.nodeName = 'period') then
        result.period := ParseInterval_date(child)
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonLanguage(element : IXmlDomElement) : TPersonLanguage;
var
  child : IXMLDOMElement;
begin
  result := TPersonLanguage.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'code') then
        result.code := child.text
      else if (child.nodeName = 'use') then
        result.use := TLanguageUse(ParseEnum(CODES_TLanguageUse, child.text))
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePersonRelatedPerson(element : IXmlDomElement) : TPersonRelatedPerson;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPersonRelatedPerson.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'id') then
        result.id := ParseHumanId(child)
      else if (child.nodeName = 'role') then
        result.role := ParseCodeableConcept(child)
      else if (child.nodeName = 'name') then
        result.name := ParseHumanName(child)
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParsePerson(element : IXmlDomElement) : TPerson;
var
  child : IXMLDOMElement;
  item : IXMLDOMElement;
begin
  result := TPerson.create;
  try
    result.xmlId := TMsXmlParser.GetAttribute(element, 'xml:Id');
    child := TMsXmlParser.FirstChild(element);
    while (child <> nil) do
    begin
      if (child.nodeName = 'identifiers') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'identifier') Then
            result.Identifier.Add(ParseHumanId(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'names') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'name') Then
            result.Name.Add(ParseHumanName(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'addresses') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'address') Then
            result.Address.Add(ParseAddress(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'contacts') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'contact') Then
            result.Contact.Add(ParseContact(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'dob') then
        result.dob := child.text
      else if (child.nodeName = 'gender') then
        result.gender := ParseCodeableConcept(child)
      else if (child.nodeName = 'religion') then
        result.religion := ParseCodeableConcept(child)
      else if (child.nodeName = 'qualifications') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'qualification') Then
            result.Qualification.Add(ParsePersonQualification(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'languages') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'language') Then
            result.Language.Add(ParsePersonLanguage(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else if (child.nodeName = 'relatedPeople') then
      begin
        item := TMsXmlParser.FirstChild(child);
        while (item <> nil) do
        begin
          if (item.nodeName = 'relatedPerson') Then
            result.RelatedPerson.Add(ParsePersonRelatedPerson(child))
          else
            ; // error?;
          item := TMsXmlParser.NextSibling(item);
        end;
      end
      else
         ; // don't raise an issue?
      child := TMsXmlParser.NextSibling(child);
    end;

    result.link;
  finally
    result.free;
  end;
end;

function TFHIRXmlParser.ParseResource(element : IXmlDomElement) : TFHIRResource;
begin
  if (element = nil) Then
    Raise Exception.Create('error - element is nil')
  else if element.NodeName = 'Conformance' Then
    result := ParseConformance(element)
  else if element.NodeName = 'Document' Then
    result := ParseDocument(element)
  else if element.NodeName = 'Message' Then
    result := ParseMessage(element)
  else if element.NodeName = 'MessageConformance' Then
    result := ParseMessageConformance(element)
  else if element.NodeName = 'Agent' Then
    result := ParseAgent(element)
  else if element.NodeName = 'Animal' Then
    result := ParseAnimal(element)
  else if element.NodeName = 'Prescription' Then
    result := ParsePrescription(element)
  else if element.NodeName = 'Patient' Then
    result := ParsePatient(element)
  else if element.NodeName = 'Organization' Then
    result := ParseOrganization(element)
  else if element.NodeName = 'DocumentConformance' Then
    result := ParseDocumentConformance(element)
  else if element.NodeName = 'LabReport' Then
    result := ParseLabReport(element)
  else if element.NodeName = 'Person' Then
    result := ParsePerson(element)
  else
    raise Exception.create('error: the element '+element.NodeName+' is not a valid resource name');
end;


end.

