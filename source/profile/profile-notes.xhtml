
<!-- Comments on the resource:
- I challenge whether "evidence" is in the 80%.  Same for endorser.  It might be used for some types of template systems, but a lot of profiling will be done that won't care about these things
- order of elements differs in diagram from XML
- suggest changing name of Profile.profile to Profile.imports.  That would be consistent with the naming of "supercedes" which also references profiles
- doesn't resourceType need to allow for "custom" resources too?
- Profile.resource.purpose: "Why describe this resource" is weak.
- I think xpath needs to be broken into a structure which includes xpath and human text
-  *Need this to generate schematron output which has to be human readable
-  *In some cases, xpath won't be able to do the job - e.g. vocab subsumption.
- Need to capture the rules about use of "mapping" being a further constraint, not a replacement of.  At least when it applies to RIM.
- Definitions for mustSupport and mustUnderstand need serious work.  Also, you mark them as optional.  That implies a default, but one isn't declared anywhere.  Do all booleans default to false?  Even if so, being explicit would be better
- Which brings up the question of: Should FHIR support defaulting?
- No clue what you meant by Profile.extensionDefn.contextType
- You're inconsistent in how you reference re-used types.  For author and endorser, you spell out the content both times.  For Profile.resource.element and Profile.extensionDefn.element, you do a funky reference thing.
-  * The funky reference thing should do a hyperlink in the HTML.  (yes, I know this means you need to put ids on stuff.)
- Need to define the "may be required" stuff for binding elements.
-->
<p>
Metadata Notes:
</p>
<ul>
<li>The name of the profile is not required to be globally unique, but the name should have some scoping information (i.e. Acme Inc (USA), Allergy List)</li>
<li>Multiple codes may be assigned to the profile. These may either describe the template, or the focus of the template, or both. They are solely to help find the profile by searching for structured concepts</li>
<li>If other profiles are referenced, then any constraints in those profiles also apply to this profile. If a resource or binding is 
found in this profile, the constraints described must include all the constraints found in the referenced profiles, so 
that it is not necessary to search the referenced profiles and merge the constraints. The primary use of referencing other 
profiles is to re-use vocabulary binding constraints</li>
<!-- The idea of "must include all the constraints in this profile of referenced profiles" falls down in the face of versioning.  If the referenced profile is updated, then what happens?  That's one of the points of referencing.
I think there needs to be two levels of profiles.  Definitional - where constraints haven't been propagated, and Runtime - where they have. -->
</ul>  

<p>
Interpretation Notes:
</p>
<ul>
<li>The name of the resource (Profile.resource.name) is only used as a logical target for .element.aggregation.reference. A reference may reference another resource 
  constraint in same resource by Profile.resource.name as #[name]), or a different resource constraint in another profile by an absolute uri. In the case of an absolute uri, it 
  must resolve literally or logically to a <a href="profile.htm">Resource Profile</a> and specify a #[name] portion in the URI</li>
  
<li>The constraint statement has a flat list of elements. The path element provides the overall structure and it must match the structure and names in the resource structure exactly</li>

<li>The condition element must be present if the conformance value is conditional. There is no formal computable grammar for the condition, though it may be accompanied by an xpath statement, often on the parent element</li>
<!-- The thing is, the condition may be best stated at a higher level.  If the condition is "may have either A or B, but not both", the constraint should appear on the common ancestor of A and B. -->

<li>The type is used to specify which types apply when the underlying resource allows a choice of types. 
When the type of the element is fixed in the underlying resource definitions, it should still be stated in the profile. The type is optional because repeating groups of elements do not have a type. </li>

<li>Definition is provided so that the constraint statement can provide a more specific definition for the field in a specific context. 
  For instance, the underlying resource definition might be "Result value", and the more specific resource definition could be "Plasma Cholesterol Test Value".
  The meaning needs to be consistent with the underlying definition, but narrower - a constraint on it. If no definition is provided, the inherited definition
  still applies</li>
  
<li>For an element with a maximum cardinality of 1, there can only be one entry in the value list, which is either a literal fixed type (with an element name matching the type of the fixed value), or a name,
  which is a reference to a named constraint pattern. If the element has a type of "list", then there can be multiple values - again, either fixed values with a type, or a named constraint. 
  Each of these appears in the list with the order and cardinality specified. By this means, a list may be "sliced" into a series of different components</li>

<li>There can be more than one entry for each element path. The constraint specification can define multiple different constraints for any element, and 
  then use them in different places. In practice, this is useful when slicing a list, and the differently named constraint profiles are invoked using the 
  <i>values</i> element. The name of the element constraint must be unique within the constraint specification for that resource. If a constraint does not 
  have a name, it applies to the base resource, and must be found in the correct place in the structure</li>
  
</ul>
<!-- Can the same resource be referenced multiple times with different sets of constraints, and if so, what would that mean?  I can think of situations where Person might be referenced 
in different places with different cosntraints, but if you do that, then you need to be able to say for each resource that references person, which constraint set from within the profile 
did you want to apply? -->

<p>
TODO: Is any control over narrative required?
</p>


<h2>
Searching Criteria
</h2>
<p>
The following simple search/filter parameters are defined for Resource Profiles:
</p>
<table class="list">
  <tr><td>name   </td><td>a portion of the name of the resource</td></tr>
  <tr><td>word   </td><td>a word somewhere in the definition of the resource or the elements in the resource. (Common words  - 'and' etc - are often not supported)</td></tr>
  <tr><td>author </td><td>name or id of the author</td></tr>
  <tr><td>code   </td><td>a code in the format uri::code</td></tr>
  <tr><td>extension </td><td>an extension code</td></tr>
  <tr><td>binding </td><td>a vocabulary binding code</td></tr>
  <tr><td>status </td><td>a status of the profile</td></tr>
  <tr><td>type   </td><td>type of resource that is constrained in the profile</td></tr>
  <tr><td>domain </td><td>concept domain that is constrained in the resource</td></tr> 
</table>
<p>
The standard search parameters also apply (see <a href="http.htm#search">Searching</a>).
</p>

<h2>Profiled FHIR</h2>
<p>
If a profile is unambiguous, then the FHIR profile tooling (ref to be provided) 
is able to generate reference implementation based object models that express 
the profiled model natively, where the object interface does not include 
prohibited elements, treats declared extensions as primary properties, and 
slices lists according to the profile. This eases the burden on an implementer, 
though this object model can only be used with a sub-set of the possible resources.
</p>
<p>
The tooling is also able to generate bi-directional transforms between the 
<a href="xml.htm">normal XML format</a> and an XML representation of this 
profiled object model, and schema for this profiled XML representation. 
This XML form has extensions promoted into the primary XML form by using the 
extension code as the XML name, and sliced lists are renamed to use the 
Profile.resource.element.name as the XML element name. Profiles are only suitable
for this use if they ensure that there are no clashing extension names when
the extension definition spaces are ignored, and that the sliced list names are 
appropriate.
</p>
<!-- Extension code as the element name won't fly.  Can have multiple extensions with the same name.  You're going to need to be able to alias names in a profile.  And the alias name is what should be used. Element names from codes is a bad scene.-->
<p>
Implementations are allowed to exchange this profiled XML format. Implementations
that do so are not fully conformant to FHIR; instead they can claim to be conformant
to "Profiled FHIR". Implementations should consider carefully before adopting this 
approach; while it will reduce the amount of work required to initially implement 
particular profiles, it will increase the amount of work required to exchange this
data with other communities, or to re-use tooling and applications that are also 
used in other contexts. This cost should particularly be considered in light of the
fact that the previously discussed tooling allows applications to be written as 
though they are dealing with "Profiled FHIR" instances when they are in fact sending
and receiving fully conformant FHIR instances.
</p>

