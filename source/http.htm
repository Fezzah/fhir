<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
todo:
  register media types for text/xml+fhir application/json+fhir
  replace dependency e-tags with version specific content location. but continue to use etag as well
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>HTTP/RESTful Framework - FHIR v<%version%></title>
    <link rel="Stylesheet" href="fhir.css" type="text/css"/>
    <link rel="Stylesheet" href="fhir-print.css" type="text/css" media="print" />
</head>

<body>
<%sidebar%>

<%maindiv%>
<%pageheader%>
[%onthispage General Issues#root|operations#read|Binary Support#binary|hData Information#hdata|Summary#summary%]

<h1>RESTful HTTP Details</h1>

<p>
In addition to the set of base resources, FHIR also provides a simple RESTful 
implementation using <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP</a>.
Each resource type has the same set of interactions defined that can be used to manage the resources 
in a highly granular fashion. Applications claiming conformance to this framework
claim to be conformant to "RESTful FHIR".
</p>
<p>
Note that in this RESTful framework, transactions are performed directly on the server resource using an 
HTTP request/response. These HTTP calls may be authenticated against a single user account (including 
using <a href="http://www.oauth.org">OAuth</a>), but this arrangement doesn't cater for common transaction metadata such as multiple users, 
responsible party, reasons, consents, etc. that are commonly encountered in healthcare. Instead, 
use of this RESTful implementation assumes that appropriate security and logs are managed by the client (perhaps 
through using <a href="http://wiki.ihe.net/index.php?title=Audit_Trail_and_Node_Authentication">ATNA</a>), and 
that the server trusts the client to maintain these. One implication is that this RESTful framework is 
only suitable for use where such trust relationships exist (e.g. in a single institution) and is not 
suitable where such trust does not exist (e.g. state &amp; national EHR systems and health record 
systems that support disparate systems). Similarly, this simple RESTful interface has no support for 
explicit archiving and similar functions. Use-cases where these kind of features are required should 
consider a <a href="message.htm">messaging</a> or <a href="implementation.htm#SOA">SOA-based approach</a> or 
some other kind of profiled REST interface.
</p>
<p>
The following logical interactions are supported:
</p>
<a name="interactions"></a>
<table class="list"> 
  <tr><td><b>Instance Level Operations</b></td><td></td></tr>
  <tr><td><a href="#read">read</a></td><td>Read the current state of the resource</td></tr>
  <tr><td><a href="#vread">vread</a></td><td>Read the state of a specific version of the resource</td></tr>
  <tr><td><a href="#update">update</a></td><td>Update an existing resource by its id (or create it if it is new)</td></tr>
  <tr><td><a href="#delete">delete</a></td><td>Delete a resource</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for a particular resource</td></tr>
  <tr><td colspan="2"><b>Type Level Operations</b></td></tr>
  <tr><td><a href="#create">create</a></td><td>Create a new resource with a server assigned id</td></tr>
  <tr><td><a href="#search">search</a></td><td>Search the resource type based on some filter criteria</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for a particular resource type</td></tr>
  <tr><td><a href="#validate">validate</a></td><td>Check that the content would be acceptable as an update</td></tr>
  <tr><td colspan="2"><b>Whole System Operations</b></td></tr>
  <tr><td><a href="#conformance">conformance</a></td><td>Get a conformance statement for support of this resource type</td></tr>
  <tr><td><a href="#batch">batch</a></td><td>Update or create a set of resources</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for all resources</td></tr>
</table>

<p>
Note that while these same logical interactions are defined on all resources, applications are 
not required to implement all of them, except for the conformance statement: applications SHALL 
provide a <a href="conformance.htm">conformance statement</a> that says what interactions are 
supported for any resource types that they support.
</p>

<a name="root"> </a>
<a name="general"> </a>
<h2>Service Root URL</h2>
<p>
The Service Root URL is the address where all of the 
resources defined by this interface are found. The Service 
Root URL takes the form of 
</p>
<pre>
http(s)://server[/path]
</pre>
<p>
The optional path may end with a trailing slash or not. Each 
resource type defined in this specification has a manager (or "entity set")
that lives at the address "/[name]" where the
name is the name of the resource type in lower case. 
For instance, the resource manager for the type 
"Patient" will live at:
</p>
<pre>
http://server/path/patient
</pre>
<p>
All the logical operations are defined relative to this service root
URL. Note that this means that given the address of any one FHIR
resource on a system, the correct address for all the other resources 
may be determined. However since application URLs may change and because in some uses of FHIR within internal eco-systems,
local configuration may dictate that the provider of a resource is different
to that claimed by any particular provider or consumer, 
applications may need to replace Service Root URLs.
</p>
<p>
Note: All URLs (and ids that form part of the URL) defined by this specification are case sensitive. 
</p>
<h2>Resource Metadata and Versioning</h2>
<p>
Each resource has an associated set of <a href="resources.htm#metadata">resource metadata elements</a>. These map to the http request and response using the following fields:
</p>
<table class="grid">
  <tr><th>Metadata Item</th><th>HTTP Response Header</th></tr>
  <tr><td>Id</td><td>The Id is represented explicitly in the URL</td></tr>
  <tr><td>Version Id</td><td>The Version Id is represented by the full canonical URL in the content-location header (see <a href="#vread">vread</a> below). 
     The Version Id may also be represented in the http ETag, but the use of ETag is not needed by this specification</td></tr>
  <tr><td>Last Modified Date</td><td>HTTP Last-Modified header</td></tr>
</table>
<p></p>

<h2>Security</h2>
<p>
For this specification, normal HTTP security and authentication rules apply. The Service Root URL will specify 
whether SSL is required. HTTP authentication may be required by the server, possibly including the requirement for 
client certificates. It is a matter of application requirements and local configuration whether all 
interactions run under the account of a trusted system user, whether each interaction runs under the 
account of the individual user or whether some other arrangement is required. 
</p>
<p>
<a href="http://oauth.net/">OAuth</a> may be used to provide security. Applications are recommended to use the variants of the OAuth protocol 
that do not require URL parameters, but these may be used if necessary.
</p>
<h2>HTTP Status Codes</h2>
<p>
This specification makes rules about the use of specific HTTP status codes 
in particular circumstances where the status codes must map to particular 
states correctly, and only where the correct status code is not obvious. 
Other HTTP status codes may be used for other states as appropriate.
Note that some security layers may issue redirects which should not be interpreted
to change the location of the resource itself (a common web programming error). 
</p>
<p>
FHIR defines an <a href="issuereport.htm">Issue Report resource</a> that can be used to convey specific detailed
processible error information. For a few combinations of operations and specific
return codes, an Issue Report is required to be returned as the content of the response. 
The Issue Report may be returned with any HTTP 4xx or 5xx response, but is not required - many of 
these errors may be generated by generic server frameworks underlying a FHIR server.
</p>

<h2>Content Types and encodings</h2>
<p>
The formal MIME-type for FHIR resources is text/xml+fhir (still to be registered) and SHOULD be use 
by clients and servers. Servers are required to support the XML format of the resources defined in this
specification, but may support other alternatives, including the <a href="formats.htm#json">JSON</a> representation. Servers must support server-driven content negotiation
as described in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html#sec12">section 12</a> 
of the HTTP specification, but in order to support various implementation limitations, may choose to 
support the (?_format=) parameter to specify alternative response formats by their MIME-types.
For the _format parameter, the values "xml", "text/xml" and "text/xml+fhir" must be interpreted to mean
the normative XML format defined by FHIR and "json" and "application/json" must be interpreted to mean the
informative JSON format.
</p>
<p>
FHIR uses UTF-8 for all request and response bodies. Since the HTTP specification (section 3.7.1)
defines a default character encoding of ISO-8859-1, requests and responses MUST explicitly set
the character encoding to UTF-8 using the 'charset' parameter of the MIME-type in the Content-Type header. 
Requests MAY also specify this charset parameter in the Accept header and/or use the Accept-Charset header.
</p>

<a name="read"> </a>
<h2>read</h2>
<p>
The read interaction accesses the current contents of a resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id} (?_format=mimeType) 
</pre>
<p>
This returns a single instance with the content specified for the resource type.
This url may be accessed by a browser. The logical id is preceded by a "@" to make parsing the url easier.
The possible values for the id itself are described in the <a href="datatypes.htm#id">id type</a>.
Servers are required to return a content-location header with the response which is the full version 
specific url (see vread below) and a Last-Modified header.
<p>
Note: Unknown resources and deleted resources are treated differently on a read: A GET for a deleted 
resource returns a 410 status code, whereas a GET for an unknown resource returns 404.
</p>

</p>
<a name="vread"> </a>
<h2>vread</h2>
<p>
The vread interaction preforms a version specific read of the resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history/{@vid} (?_format=mimeType)
</pre>
<p>
This returns a single instance with the content specified for the resource type for that
version of the resource. Servers may return a content-location header with the response which is the url 
requested and a Last-Modified header. 
</p>
<p>
The version id is an opaque identifier that conforms to the same format requirements as 
a resource id. The id may have been found by performing a history operation (see below), by recording the 
version id from a content location returned from a read or from a version specific reference in a 
content model. If the version referred to is actually one where the resource was deleted, the 
server should return a 410 status code.
</p>
<p>
Servers SHOULD support a version specific retrieval of the current version of the 
resource even if they are unable to support access to previous versions. 
</p>
<a name="update"> </a>
<h2>update</h2>
<p>
The update interaction changes an existing resource or creates a new resource if it doesn't already exist. 
The update interaction is performed by an HTTP PUT operation as shown:
</p>
<pre>
  PUT [service-url]/[resourcetype]/{@id} (?_format=mimeType)
</pre>
<p>
If the operation is successful, the server must return 200 OK, along with a copy of the 
newly updated resource (which might not be the same as that submitted) with the response, along 
with a Last-Modified header, and a Content-Location header that refers to the version created by the 
updated operation.
</p>
<p>
Servers are permitted to reject update operations because of integrity concerns or business 
rules implemented on the server, and return HTTP status codes accordingly. 
</p>
<p>
In particular, servers may choose to implement version-aware updates, where the only updates that are 
accepted quote the current version of the resource. In this case, the client must submit the currently 
correct version specific URL in the Content-Location in the PUT request. If the value is missing, 
the server SHALL return a 412 Preconditions failed response. Clients SHOULD submit a proper Content-Location 
header and SHALL correctly understand a 409 response as an update conflict.
</p>
<p>
The following resources may require special handling on the server when updated (whether directly or as part of a batch):
</p>
<ul>
 <li><a href="provenance.htm">Provenance</a></li>
 <li><a href="patient.htm">Patient</a></li>
 <li><a href="securityevent.htm">SecurityEvent</a> (generally, updates are inappropriate)</li>
</ul>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or failed basic basic FHIR validation rules</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>405 Method Not allowed</b> - the resource did not exist prior to the update, and the serer does not allow client defined ids</li>
 <li><b>409/412</b> - version conflict management - see above</li> 
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the proposed resource violated applicable FHIR profiles or server business rules. This should be accompanied by an <a href="issuereport.htm">Issue</a> resource providing additional detail</li>
</ul>
<a name="delete"> </a>
<h2>delete</h2>
<p>
The delete interaction removes an existing resource. The interaction
is performed by an HTTP DELETE operation as shown:
</p>
<pre>
  DELETE [service-url]/[resourcetype]/{@id} 
</pre>
<p>
A delete operation means that <a href="#read">non-version specific reads</a> of a resource 
return a 410 error and that the resource is no longer found through search operations. Upon successful
deletion the server should return 204 (No Content). If the server refuses to delete resources of 
that type on principle, then it should return the status code 
405 method not allowed. If the server refuses to delete a resource because of reasons specific 
to that resource, such as referential integrity, it should return the status code 409 Conflict.
If the resource cannot be deleted because it does not exist on the server, the server must return 404 (Not found).
Performing this operation on a resource that is already deleted has no effect, and should return 204.
Resources may be undeleted by PUTting an update to them subsequent to the deletion. 
</p>
<p>
Many resources have a status element that overlaps with the idea of deletion. Each resource type
defines what the semantics of the deletion operations are. If no documentation is provided, the 
deletion operation should be understood as deleting the record of the resource, with nothing
about the state of the real-world corresponding resource implied.
</p>
<p>
The following resources may require special handling on the server when deleted 
(whether directly or as part of a batch):
</p>
<ul>
 <li><a href="patient.htm">Patient</a></li>
 <li><a href="securityevent.htm">SecurityEvent</a> (generally, deletes are inappropriate)</li>
</ul>
<a name="create"> </a>
<h2>create</h2>
<p>
The create interaction creates a new resource. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url]/[resourcetype] (?_format=mimeType)
</pre>
<p>
The server returns a 201 Created, along with a copy of the newly created resource 
(which might not be the same as that submitted) with the acknowledgement, along with 
a version-aware Location header which contains the new location and id of the created resource:
</p>
<pre>
  Location: [service-url]/[resourcetype]/{@new-id}/history/{@new-vid}
</pre>
<p>
When the payload data is incorrect and cannot be used to create a new resource, the server returns a 400 Bad Request.

Note: If the client wishes to have control over the id of a newly submitted resource, it should use 
the update operation instead.
</p>
<p>
The following resources may require special handling on the server when created (whether directly or as part of a batch):
</p>
<ul>
 <li><a href="provenance.htm">Provenance</a></li>
 <li><a href="patient.htm">Patient</a></li>
</ul>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or failed basic basic FHIR validation rules</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the proposed resource violated applicable FHIR profiles or server business rules. This should be accompanied by an <a href="issuereport.htm">Issue</a> resource providing additional detail</li>
</ul>

<a name="search"> </a>
<h2>search</h2>
<p>
This interaction searches a resource type based on some filter criteria. The interaction is performed by two different HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/search(?parameters) (&amp;format=mimeType)
  GET [service-url]/[resourcetype]/(?parameters) (&amp;format=mimeType)
</pre>
<p>
Because of the way that some user agents treat POST requests, POST submissions are also allowed, though the semantics are exactly the 
same as a GET operation. Search operations take a series of parameters that are encoded in the URL or as an x-multi-part-form submission
for a POST. The return content is an <a href="resources.htm#bundle">Bundle</a> containing the results of the search as a list of resources
in a defined order. 
</p>
<p>
In order to allow the client to be confident about what search parameters were used as a criteria by the server, 
the server SHALL return the parameters that were actually used in a search URL as the self link in the atom feed that is returned.
</p>
<a name="pages"> </a>
<p> 
Servers SHOULD conform to the method described in <a href="https://tools.ietf.org/html/rfc5005">RFC 5005 (Feed 
Paging and Archiving)</a> for sending search continuation links to the client. If the server does not do this, 
there is no way to continue the search.
</p>
<p>
This example shows the third page of a search for all patients with the name "peter":
</p>

<pre>
&lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
  &lt;title&gt;Sarch Page 3&lt;/title&gt;
  &lt;!-- This Search. url starts with base search, and adds the effective 
    parameters, and additional parameters for search state. All searches SHALL return this value.    
	
	In this case, the search continuation method is that the server maintains a state, with page
	refernces into the stateful list.
	--&gt;
  &lt;link rel="self" href="http://example.org/patient/search?name=peter&amp;stateid=23423443&amp;page=3"/&gt;

  &lt;!-- 4 links for navigation in the search. All of these are optional, but recommended --&gt;  
  &lt;link rel="first" href="http://example.org/patient/search?name=peter&amp;stateid=23423443&amp;page=1"/&gt;
  &lt;link rel="previous" href="http://example.org/patient/search?name=peter&amp;stateid=23423443&amp;page=2"/&gt;
  &lt;link rel="next" href="http://example.org/patient/search?name=peter&amp;stateid=23423443&amp;page=4"/&gt;
  &lt;link rel="last" href="http://example.org/patient/search?name=peter&amp;stateid=23423443&amp;page=26"/&gt;
  &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;

  &lt;!-- the rest of the search results... --&gt;  
&lt;/feed&gt;
</pre>

<p>
The server need not use a stateful search method as shown in this example - it is at 
the discretion of the server how to best ensure that the search continuation retains 
integrity in the context of ongoing changes to the resources. An alternative approach
is to use version specific references to the records on the boundaries, but this is 
subject to continuity failures when records are updated.
</p>

<pre>
TODO: sorting - need to find a balance between something that is is possible and something that is useful
</pre>
<h3>Search Parameters</h3>
<p>
Each FHIR resource type defines a set of applicable search parameters with their names, types, repeat behaviour, and meanings. 
Mostly, the defined search parameters correspond to a single element in the resource, but this is not required, and some 
search parameters refer to the same type of element in multiple places, or refer to derived values.
The result of the search operation is the intersection of the resources that match the criteria specified by the different search parameters.
Where the same parameter is specified more than once, the criteria may be interpreted as either an intersection or a union, or the server
the should return an error. The correct action is defined along with the parameter. Parameter values are not case-sensitive.
</p>
<p>
In addition, the following common search parameters apply to all resource types:
</p>
<table class="list">
  <tr><td>_count : <a href="datatypes.htm#integer">integer</a></td><td><i>single</i></td><td>Number of return records requested. The server is not bound to conform</td></tr>
  <tr><td>_id : <a href="datatypes.htm#id">token</a></td><td><i>single</i></td><td>The <a href="resources.htm#metadata">logical resource id</a> associated with the resource (must be supported by all servers)</td></tr>
  <tr><td>_include : <a href="datatypes.htm#id">token</a></td><td><i>union</i></td><td>See below</td></tr>
  <tr><td>_inline : <a href="datatypes.htm#id">token</a></td><td><i>union</i></td><td>See below under _include</td></tr>
</table>


<h3>Search Parameter Types</h3>
<%codelist SearchParamType%>

<p>
For QToken searches:
</p>
<ul>
 <li><b>name=namespace#code</b> specifies matches on both the namespace and the code</li>
 <li><b>name=#code</b> matches a code that has no specified namespace</li>
 <li><b>name=code</b> matches all codes irrespective of the namesapce</li>
</ul>
<p>
When the QToken parameter refers to a resource reference, the correct namespace to
use is "http://hl7.org/fhir/resource-types#[Name]", where Name is the title of the 
resource (the <a href="terminologies.htm#resourcetypes">variant of the resource name with upper case letters</a>).
</p>


<h3>Search Parameter Repeat Behaviour</h3>
<%codelist SearchRepeatBehavior%>

<h3>Parameter Chaining</h3>
<p>
Parameters may be "chained" by appending them together separated by "." following a logical path through a graph of related resources.
For instance, given that the resource "LabReport" has a search parameter named <i>patient</i>, which is a reference to a "Patient" resource,
and the Patient resource includes a parameter <i>person</i>, which is a reference to the "Person" resource, and the person resource has a search 
parameter <i>name</i> which searches on patient name, then the search
</p>
<pre>
 LabReports/search?patient.person.name=peter
</pre>
<p>
is a request to return all the lab reports that have a subject whose name includes "peter". 
</p>

<h3>Searching for Missing Values</h3>
<p>
Parameters that have no value should be ignored:
</p>
<pre>
  GET [service-url]/[resourcetype]/search?name=
</pre>
<p>
In order to support searching for missing values, for each defined parameter on a resource, there is an implicit "-missing" parameter.
For instance, if the resource defines a parameter "gender", then there is an implicitly defined parameter "gender-missing". 
Seaching for "gender-missing=true" will return all the resources that don't have any value for the gender parameter (which usually 
equates to not having the relevent element in the resource). Searching for "gender-missing=false"
will return all the resources that have a value for the "gender" parameter. 
</p>

<h3>Including other resources in result (_include)</h3>
<p>
Clients may request that the server return additional resources related to the search results, in order to reduce the overall network
query time. A typical case where this is useful is where the client is querying on the patient resource, but for every patient resource
returned, the client will also need the person resource that the patient refers to. The client requests this by providing one or more
_include parameters.
</p>
<p>  
Each _include parameter specifies a path in a URL (as an XPath value):
</p>
<pre>
 LabReports/search?_include=LabReport/patient&amp;_include=Patient/subject
</pre>
<p> 
For each returned resource, the server executes the XPath statement, 
and, if it matches one or more resource references, and it is able to locate the targets, 
appends the target resource to the return result.
Note that _include parameters may be recursive. For instance, a client may request to return all the 
patients associated with a search on lab reports, and then to include all the person resources for 
the patients returned, as shown above. 
</p>
<p>
For servers, Recursive parameters are demanding and slow the search response
time, 
</p>
<p>
If the _include path matches an element of type uri rather than a resource reference, 
the server may elect to include the target of the uri reference in the returned atom feed
as a Binary resource. For example, the include path may point to an attachment which is by reference, like this:
</p>
<pre>
 &lt;content&gt;
   &lt;contentType&gt;image/jpeg&lt;/contentType&gt;
   &lt;url&gt;http://example.org/images/2343434/234234.jpg&lt;/url&gt;
 &lt;/content&gt;
</pre>
<p>
The server can retrieve the target of this reference on behalf of the client, and add this to the 
atom feed for the convenience of the client. 
</p>

<h3>Server Conformance</h3>
<p>
Servers have considerable discretion with regards to supporting to search:
</p>
<ul>
 <li>Servers can choose which parameters to support (other than _id above)</li>
 <li>Servers can choose when and where to implement parameter chaining, and when and where they support the _include parameter</li>
 <li>Servers are able to declare additional parameters in the profiles referenced from their conformance statements. Servers should define search parameters 
    with a "-" character in them to ensure that the names they choose do not clash with future parameters defined by this specification</li>
 <li>Servers are not required to enforce case sensitivity on parameter names, though the names are case sensitive (and URLs are generally case-sensitive)</li>
 <li>Servers may choose how many results to return, though the client can use _count as above</li>
 <li>Servers can choose how to sort the return results</li>
</ul>

<p>
If more sophisticated searching is required, a FHIR-based service interface can be defined to enable the workflow and
functionality desired.  
</p>

<a name="validate"> </a>
<h2>validate</h2>
<p>
The validate interaction checks whether the attached content would be acceptable as an 
update to an existing resource. The validation operation may be the first part of a light two-
phase commit process. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  todo: harmonise these with the RLUS REST specification
  POST [service-url]/[resourcetype]/validate/{@id}
</pre>
<p>
The content is first checked against the general specification and against the conformance 
profile that applies to the application. How much checking is performed is at the discretion 
of the server. Then the resource is considered as a proposed update and additional instance 
specific rules such as referential integrity and update logic (including version control) 
are applied as well. The return content has one of the following values:
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed or had some basic FHIR validation error</li>
 <li><b>200 OK</b> - resource passed all validation rules</li>
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the resource was valid, but it violates applicable FHIR profiles or server business rules</li>
</ul>
<p>
Unless the result is 200 OK, the response must include an <a href="issuereport.htm">Issue Report</a> that lists the issues found on validation.
</p>
<p>
The validation operation has complex semantics and rules; see the full discussion of the operation in the <a href="#hdata">OMG hData REST specification</a> for further details. 
</p>

<a name="conformance"> </a>
<h2>conformance</h2>
<p>
The conformance interaction retrieves the application's conformance statement for the resource. The interaction is performed by an HTTP OPTIONS or a GET operation as shown:
</p>
<pre>
  OPTIONS [service-url] (?_format=mimeType)
  GET [service-url]/metadata (?_format=mimeType)
</pre>
<p>
Applications SHALL return a <a href="conformance.htm">Conformance Resource</a> that specifies which resource types and operations are supported. 
If a 404 Unknown is returned, FHIR is not supported on the nominated service url. The GET operation is defined because not all client libraries 
are able to perform an OPTIONS operation. Additional parameters that are required to be returned with the OPTIONS command are defined in the 
<a href="#hdata">OMG hData RESTful Transport</a> specification.
</p>
<p>
Servers may choose what content to return when they receive a GET operation on the Service Root URL. Generally some page that guides 
human manual interaction with the server would be appropriate.
</p>

<a name="batch"> </a>
<h2>batch</h2>
<p>
The batch interaction submits a set of resources to be updated or created on the server. 
This interaction has two principle uses: to support push-based pub/sub, and to allow 
multiple resources to be updated/created in a single transaction. Multiple different
types of resources may be submitted, including a mix of new and existing resources. 
The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url] (?_format=mimeType)
</pre>
<p>
The content of the post submission is a resource bundle in either <a href="formats.htm#atom">XML</a> or 
<a href="formats.htm#json-bundles">JSON</a>. The resources in the bundle are each processed separately
as if they were an individual <a href="#create">create</a> or <a href="#update">update</a> as 
described below, along with the normal processing for each (such as verification and version aware updates). 
Servers SHALL either accept all resources and return a 200 OK, along with a response bundle, 
or reject all resources and return an HTTP 400 or 500 type response. It is not an error if 
the submitted bundle has no resources in it.
</p>
<p>
When a bundle is submitted in a batch operation, all the resources have an identity specified
in the bactch. If the identity of the resource matches an existing or possible resource location 
on the server, the server should treat this entry as an <a href="#update">update operation</a> 
(i.e. PUT to the given resource). If the identity is not one that the server recognises, the 
server should treat the operation as a <a href="#create">create operation</a> (i.e. POST to 
the given resource type URL), and create a new identity for the submitted resource. For 
clarity, when the client intends a resource to have a transient identity that the server
must replace, it should use a cid: url on the resource. 
</p>
<p>
If the server must assign a new identity when it accepts the resource, it SHALL also update 
any references to that resource in the same batch as they are processed. References to resources
that are not part of the batch are left untouched. If a resource in the batch carries a 
version-specific id (using its self-link), any version-specific references to it must also be updated.
Servers SHALL be replace all cid: links in the batch, whether they are found in the resource ids, 
resource references, url elements, or &lt;a href="" &amp; &lt;img src="" in the narrative.
</p>
<p>
Note that this allows clients to assign temporary (version-specific) ids to new resources and refer to
them from within the batch while the server will update these temporary ids after their creation. This
is especially useful in RESTful scenario's where one would otherwise need multiple operations, possibly
leading to loss of referential integrity (e.g. when storing a Provenance resource and its 
corresponding target resource), or, on document repositories, a document index entry and it's
accompanying document.
</p>
<p>
In order to allow the client to know how newly created resources are now identified for future 
reference, the server must return a bundle containing the created or updated resources in the same 
order that they were submitted. 
</p>

<a name="history"> </a>
<h2>history</h2>
<p>
The history interaction retrieves the history of either a particular resource, all resources of 
a given type, or all resources supported by the system. These three variations of the history
operation are performed by HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history (?_format=mimeType)
  GET [service-url]/[resourcetype]/history (?_format=mimeType)
  GET [service-url]/history (?_format=mimeType)
</pre>
<p>
The return content is a <a href="resources.htm#bundle">Bundle</a> containing the specified version history, 
sorted with oldest versions last.  
</p>
<p>
The history list can be restricted to a limited period by specifying a _last parameter which contains a full date time with timezone. 
This means that the list only includes resource versions that were created at or after the given date. 
Servers must ensure that if a client uses the feed.updated date from the last response they received as 
the value of the _last parameter, no versions will be missed. Clients should be aware that due to timing imprecision, 
they may receive notifications of a resource update on the boundary instant more than once. Servers are 
not required to support a precision finer than by second. 
</p>
<p>
The updates list can be long, so servers SHALL use the method described in <a href="https://tools.ietf.org/html/rfc5005">RFC 5005 (Feed 
Paging and Archiving)</a> (also <a href="#pages">see above</a>) for breaking the updates list into pages if appropriate.
</p>
<p>
The history operation is suitable for use with internet pub/sub systems based on rss/atom, 
including services such as Google Reader, allowing humans to easily subscribe to notifications
of updates to a resource (this is usually appropriate for low volume high knowledge resources like
profiles). In addition, the history operation can be used to set up a subscription from one system
to another, so that resources are sychronised between them. Systems receiving such feeds and planning
on enforcing resource integrity should note that batch boundaries are not reflected in the history
list.
</p>
 
<h2>Binary Support</h2>
<p>
FHIR servers can choose to offer support for purely binary resources
at the end point [service-url]/binary. The binary end-point accepts
any kind of content, such as images and other media, documents (CDA, 
PDF, Word etc), or anything else, and stores the content as is, along 
with the content type provided by the HTTP headers. 
</p>
<p>
The binary resource functions with the same operations as described
above, except that there is no support for the search operation. 
The _format  parameter has no meaning when used with binary 
resources- they are always represented using their original content type.
</p>

<h2>Intermediaries</h2>
<p>
The HTTP protocol may be routed through an HTTP proxy such as 
squid. Such proxies are transparent to the applications, though
implementers should be alert to the effects of rogue caching.
</p>
<p>
Interface engines may also be placed between the consumer and
the provider. These differ from proxies because they actively
alter the content and/or destination of the HTTP exchange and are
not bound the rules that apply to HTTP proxies. Such agents are allowed, 
but must mark the http header to assist with troubleshooting.
</p>
<p>
Any agent that modifies an HTTP request or Response content other
than under the rules for HTTP proxies must add a stamp to the HTTP 
headers like this:
</p>
<pre>
  request-modified-[identity]: [purpose]
  response-modified-[identity]: [purpose]
</pre>
<p>
The identity must be a single token defined by the administrator of the agent
that will sufficiently identify the agent in the context of use. The header
must specify the agent's purpose in modifying the content. End point systems must
not use this header for any purpose. Its aim is to assist with 
system troubleshooting.
</p>

<a name="hdata"> </a>
<h2>OMG hData RESTful Transport</h2>

<p>
This RESTful specification described here is based on the <a href="http://www.omg.org">OMG Health RESTful specification</a> (specific reference to be provided when this is published). 
In this regard, FHIR functions as a Record Format Profile as described in that specification. Note the following significant factors to be aware of:
</p>
<ul>
 <li>FHIR maps the hData sections to resource types, and hData documents to resource instances. There are no subsections, and client systems are not able to create new sections</li>
 <li>The FHIR resource id maps to the hData document name by prepending "@"</li>
 <li>Because clients cannot submit new sections (POST to service URL), POST to the service URL has been re-used for <a href="#batch">the batch operation</a> (difference under review)</li>
 <li>FHIR does not (yet) define a root document. When defined, it will contain information about what the FHIR server has done (as opposed to a conformance statement, which describes what it is capable of doing)</li>
 <li>Note that this specification does not repeat the rules in the hData RESTful Transport concerning the OPTIONS command on the service URL, but these rules (extra headers etc) still apply</li>
</ul>

<h2>Summary</h2>
<p>
These tables present a summary of the operations described here.
</p>

<table class="grid">
<tr><th>Operation</th><th>Path</th><th colspan="5">Request</th></tr>
<tr><th colspan="2"></th>                                     <th>Verb</th>         <th>Content-Type</th> <th>Body</th>     <th>Accept</th> <th>Content-Location</th></tr>
<tr><td>read</td>       <td>/[type]/@[id]</td>                <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>vread</td>      <td>/[type]/@[id]/history/@[vid]</td> <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>conformance</td><td>/ or /metadata</td>               <td>OPTIONS / GET</td><td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>update</td>     <td>/[type]/@[id]</td>                <td>PUT</td>          <td>R</td>            <td>Resource</td> <td>O</td>      <td>O or R</td></tr>
<tr><td>create</td>     <td>/[resource]</td>                  <td>POST</td>         <td>R</td>            <td>Resource</td> <td>O</td>      <td>N/A</td></tr>
<tr><td>batch</td>      <td>/</td>                            <td>POST</td>         <td>R</td>            <td>Bundle</td>   <td>O</td>      <td>N/A</td></tr>
<tr><td>delete</td>     <td>/[type]/@[id]</td>                <td>DELETE</td>       <td>N/A</td>          <td>N/A</td>      <td>N/A</td>    <td>N/A</td></tr>
<tr><td>search</td>     <td>/[type]/search</td>               <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>updates</td>    <td>/[type]/updates</td>              <td>GET</td>          <td>N/A</td>          <td>N/A</td>      <td>O</td>      <td>N/A</td></tr>
<tr><td>validate</td>   <td>/[type]/validate/@[id]</td>       <td>POST</td>         <td>R</td>            <td>Resource</td> <td>O</td>      <td>N/A</td></tr>
</table>

<p>
Note: N/A = not present, R = Required, O = optional.
</p>

<table class="grid">
<tr><th>Operation</th><th colspan="5">Response</th></tr>
<tr><th colspan="1"></th> <th>Content-Type</th> <th>Body</th>               <th>Location</th> <th>Content-Location</th> <th>Status Codes</th></tr>
<tr><td>read</td>         <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>R</td>                <td>200, 404, 410</td></tr>
<tr><td>vread</td>        <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>O</td>                <td>200, 404, 410</td></tr>
<tr><td>conformance</td>  <td>R</td>            <td>Conformance</td>        <td>N/A</td>      <td>O</td>                <td>200, 404</td></tr>
<tr><td>update</td>       <td>R</td>            <td>Resource</td>           <td>N/A</td>      <td>R</td>                <td>201, 400, 404, 405, 409, 412, 490</td></tr>
<tr><td>create</td>       <td>R</td>            <td>Resource</td>           <td>R</td>        <td>O</td>                <td>200, 201, 400, 404, 490</td></tr>
<tr><td>batch</td>        <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200, 400, 404, 405, 409, 412, 490</td></tr>
<tr><td>delete</td>       <td>N/A</td>          <td>N/A</td>                <td>N/A</td>      <td>N/A</td>              <td>204, 405, 404</td></tr>
<tr><td>search</td>       <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200</td></tr>
<tr><td>updates</td>      <td>R</td>            <td>Bundle</td>             <td>N/A</td>      <td>N/A</td>              <td>200</td></tr>
<tr><td>validate</td>     <td>N/A or R</td>     <td>N/A or IssueReport</td> <td>N/A</td>      <td>N/A</td>              <td>400</td></tr>
</table>

<p>
Note: this table lists the status codes described here, but other status codes are possible as described by the HTTP specification.
</p>


<%footer%>


<%/maindiv%>    
</body>
</html>