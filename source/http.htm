<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
todo:
  register media types for text/xml+fhir application/json+fhir
  replace dependency e-tags with version specific content location. but continue to use etag as well
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>HTTP/RESTful Framework - FHIR v<%version%></title>
    <link rel="Stylesheet" href="fhir.css" type="text/css"/>
    <link rel="Stylesheet" href="fhir-print.css" type="text/css" media="print" />
</head>

<body>
<%sidebar%>

<%maindiv%>
<%pageheader%>
<h1>RESTful HTTP Details</h1>

<p>
In addition to the set of base resources, FHIR also provides a simple RESTful 
implementation using <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP</a>.
Each resource type has the same set of interactions defined that can be used to manage the resources 
in a highly granular fashion. Applications claiming conformance to this framework
claim to be conformant to "RESTful FHIR".
</p>
<p>
Note that in this RESTful framework, transactions are performed directly on the server resource using an 
HTTP request/response. These HTTP calls may be authenticated against a single user account (including 
using <a href="http://www.oauth.org">OAuth</a>), but this arrangement doesn't cater for common transaction metadata such as multiple users, 
responsible party, reasons, consents, etc. that are commonly encountered in healthcare. Instead, 
use of this RESTful implementation assumes that appropriate security and logs are managed by the client (perhaps 
through using <a href="http://wiki.ihe.net/index.php?title=Audit_Trail_and_Node_Authentication">ATNA</a>), and 
that the server trusts the client to maintain these. One implication is that this RESTful framework is 
only suitable for use where such trust relationships exist (e.g. in a single institution) and is not 
suitable where such trust does not exist (e.g. state &amp; national EHR systems and health record 
systems that support disparate systems). Similarly, this simple RESTful interface has no support for 
explicit archiving and similar functions. Use-cases where these kind of features are required should 
consider a <a href="message.htm">messaging</a> or <a href="implementation.htm#SOA">SOA-based approach</a> or 
some kind of profiled REST interface, such as <a href="hdata.htm">hData</a>.
</p>
<p>
The following logical interactions are supported:
</p>
<a name="interactions"></a>
<table class="list"> 
  <tr><td><b>Instance</b></td><td></td></tr>
  <tr><td><a href="#read">read</a></td><td>Read the current state of the resource</td></tr>
  <tr><td><a href="#vread">vread</a></td><td>Read the state of a specific version of the resource</td></tr>
  <tr><td><a href="#update">update</a></td><td>Update an existing resource by its id (or create it if it is new)</td></tr>
  <tr><td><a href="#delete">delete</a></td><td>Delete a resource</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for the resource</td></tr>
  <tr><td colspan="2"><b>Manager</b></td></tr>
  <tr><td><a href="#create">create</a></td><td>Create a new resource with a server assigned id</td></tr>
  <tr><td><a href="#search">search</a></td><td>Search the resource type based on some filter criteria</td></tr>
  <tr><td><a href="#updates">updates</a></td><td>Get a list of prior updates to resources of this type, optionally with some filter criteria</td></tr>
  <tr><td colspan="2"><b>System</b></td></tr>
  <tr><td><a href="#validate">validate</a></td><td>Check that the content would be acceptable as an update</td></tr>
  <tr><td><a href="#conformance">conformance</a></td><td>Get a conformance statement for support of this resource type</td></tr>
  <tr><td><a href="#batch">batch</a></td><td>Update or create a set of resources</td></tr>
</table>

<p>
Note that while these same logical interactions are defined on all resources, applications are 
not required to implement all of them, except for the conformance statement: applications must 
provide a <a href="conformance.htm">conformance statement</a> that says what interactions are 
supported for any resource types that they support.
</p>

<h2>Service Root URL</h2>
<p>
The Service Root URL is the address where all of the 
resources defined by this interface are found. The Service 
Root URL takes the form of 
</p>
<pre>
http(s)://server[/path]
</pre>
<p>
The optional path may end with a trailing slash or not. Each 
resource type defined in this specification has a manager (or "entity set")
that lives at the address "/[name]" where the
name is the name of the resource type in lower case. 
For instance, the resource manager for the type 
"Patient" will live at:
</p>
<pre>
http://server/path/patient
</pre>
<p>
All the logical operations are defined relative to this service root
URL. Note that this means that given the address of any one FHIR
resource on a system, the correct address for all the other resources 
may be determined. However since application URLs may change and because in some uses of FHIR within internal eco-systems,
local configuration may dictate that the provider of a resource is different
to that claimed by any particular provider or consumer, 
applications may need to replace Service Root URLs.
</p>
<p>
Note: All URLs (and ids that form part of the URL) defined by this specification are case sensitive. 
</p>
<h2>Resource Metadata and Versioning</h2>
<p>
Each resource has an associated set of <a href="xml.htm#metadata">resource metadata elements</a>. These map to the http request and response using the following fields:
</p>
<table class="grid">
  <tr><th>Metadata Item</th><th>HTTP Response Header</th></tr>
  <tr><td>Id</td><td>The Id is represented explicitly in the URL</td></tr>
  <tr><td>Version Id</td><td>The Version Id is represented by the full canonical URL in the content-location header (see <a href="#vread">vread</a> below). 
     The Version Id may also be represented in the http ETag, but the use of ETag is not needed by this specification</td></tr>
  <tr><td>Last Modified Date</td><td>HTTP Last-Modified header</td></tr>
</table>
<p></p>

<h2>Security</h2>
<p>
For this specification, normal HTTP security and authentication rules apply. The Service Root URL will specify 
whether SSL is required. HTTP authentication may be required by the server, possibly including the requirement for 
client certificates. It is a matter of application requirements and local configuration whether all 
interactions run under the account of a trusted system user whether each interaction runs under the 
account of the individual user or whether some other arrangement is required. 
</p>
<p>
<a href="http://oauth.net/">OAuth</a> may be used to provide security. Applications are recommended to use the variants of the OAuth protocol 
that do not require URL parameters, but these may be used if necessary.
</p>
<h2>HTTP Status Codes</h2>
<p>
This specification makes some rules about the use of specific HTTP status codes 
in some particular circumstances where the status codes must map to particular 
states correctly, and only where the correct status code is not obvious. 
Other HTTP status codes may be used for other states as appropriate.
Note that some security layers may issue redirects which should not be interpreted
to change the location of the resource itself (a common web programming error). 
</p>
<h2>Content Types and encodings</h2>
<p>
The formal MIME-type for FHIR resources is text/xml+fhir (still to be registered) and SHOULD be use 
by clients and servers. Servers are required to support the XML format of the resources defined in this
specification, but may support other alternatives, including the informative 
<a href="json.htm">JSON</a> representation. Servers must support server-driven content negotiation
as described in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html#sec12">section 12</a> 
of the HTTP specification, but in order to support various implementation limitations, may choose to 
support the (?$format=) parameter to specify alternative response formats by their MIME-types.
For the $format parameter, the values "xml", "text/xml" and "text/xml+fhir" must be interpreted to mean
the normative XML format defined by FHIR and "json" and "application/json" must be interpreted to mean the
informative JSON format.
</p>
<p>
FHIR uses UTF-8 for all request and response bodies. Since the HTTP specification (section 3.7.1)
defines a default character encoding of ISO-8859-1, requests and responses MUST explicitly set
the character encoding to UTF-8 using the 'charset' parameter of the MIME-type in the Content-Type header. 
Requests MAY also specify this charset parameter in the Accept header and/or use the Accept-Charset header.
</p>

<a name="read"> </a>
<h2>read</h2>
<p>
The read interaction accesses the current contents of a resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id} (?$format=mimeType) 
</pre>
<p>
This returns a single instance with the content specified for the resource type.
This url may be accessed by a browser. The logical id is preceded by a "@" to make parsing the url easier.
The possible values for the id itself are described in the <a href="datatypes.htm#id">id type</a>.
Servers are required to return a content-location header with the response which is the full version 
specific url (see vread below) and a Last-Modified header.
<p>
Note: Unknown resources and deleted resources are treated differently on a read: A GET for a deleted 
resource returns a 410 status code, whereas a GET for an unknown resource returns 404.
</p>

</p>
<a name="vread"> </a>
<h2>vread</h2>
<p>
The vread interaction preforms a version specific read of the resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history/{@vid} (?$format=mimeType)
</pre>
<p>
This returns a single instance with the content specified for the resource type for that
version of the resource. Servers may return a content-location header with the response which is the url 
requested and a Last-Modified header. 
</p>
<p>
The version id is an opaque identifier that conforms to the same format requirements as 
a resource id. The id may have been found by performing a history operation (see below), by recording the 
version id from a content location returned from a read or from a version specific reference in a 
content model. The vread interaction for a version that marks the deletion of the resource should succeed 
as long as a correct version identifier is provided, in which case a 410 status code is returned.
</p>
<p>
Servers SHOULD support a version specific retrieval of the current version of the 
resource even if they are unable to support access to previous versions. 
</p>
<a name="update"> </a>
<h2>update</h2>
<p>
The update interaction changes an existing resource or creates a new resource if it doesn't already exist. 
The update interaction is performed by an HTTP PUT operation as shown:
</p>
<pre>
  PUT [service-url]/[resourcetype]/{@id} (?$format=mimeType)
</pre>
<p>
If the operation is successful, the server must return 200 OK, along with a copy of the 
newly updated resource (which might not be the same as that submitted) with the response, along 
with a Last-Modified header, and a Content-Location header that refers to the version created by the 
updated operation.
</p>
<p>
Servers are permitted to reject update operations because of integrity concerns or business 
rules implemented on the server, and return HTTP status codes accordingly. 
</p>
<p>
In particular, servers may choose to implement version-aware updates, where the only updates that are 
accepted quote the current version of the resource. In this case, the client must submit the currently 
correct version specific URL in the Content-Location in the PUT request. If the value is missing, 
the server SHALL return a 412 Preconditions failed response. Clients SHOULD submit a proper Content-Location 
header and SHALL correctly understand a 409 response as an update conflict.
</p>
<p>
The following resources may require special handling on the server when updated (whether directly or as part of a batch):
</p>
<ul>
 <li><a href="provenance.htm">Provenance</a></li>
 <li><a href="patient.htm">Patient</a></li>
 <li><a href="securityevent.htm">SecurityEvent</a> (generally, updates are inappropriate)</li>
</ul>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>405 Method Not allowed</b> - the resource did not exist prior to the update, and the serer does not allow client defined ids</li>
 <li><b>409/412</b> - version conflict management - see above</li> 
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the proposed resource violated server business rules. This should be accompanied by an <a href="issuereport.htm">Issue</a> resource providing additional detail</li>
</ul>
<a name="delete"> </a>
<h2>delete</h2>
<p>
The delete interaction removes an existing resource. The interaction
is performed by an HTTP DELETE operation as shown:
</p>
<pre>
  DELETE [service-url]/[resourcetype]/{@id} 
</pre>
<p>
A delete operation means that <a href="#read">non-version specific reads</a> of a resource 
return a 410 error and that the resource is no longer found through search operations. Upon successful
deletion the server should return 204 (No Content). If the server refuses to delete resources of 
that type on principle, then it should return the status code 
405 method not allowed. If the server refuses to delete a resource because of reasons specific 
to that resource, such as referential integrity, it should return the status code 409 Conflict.
If the resource cannot be deleted because it does not existe on the server, the server must return 404 (Not found).
Performing this operation on a resource that is already deleted has no effect, and should return 204.
Resources may be undeleted by PUTting an update to them subsequent to the deletion. 
</p>
<p>
Many resources have a status element that overlaps with the idea of deletion. Each resource type
defines what the semantics of the deletion operations are. If no documentation is provided, the 
deletion operation should be understood as deleting the record of the resource, with nothing
about the state of the real-world corresponding resource implied.
</p>
<p>
The following resources may require special handling on the server when deleted 
(whether directly or as part of a batch):
</p>
<ul>
 <li><a href="patient.htm">Patient</a></li>
 <li><a href="securityevent.htm">SecurityEvent</a> (generally, deletes are inappropriate)</li>
</ul>
<a name="history"> </a>
<h2>history</h2>
<p>
The history interaction retrieves the history of the resource. The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history (?$format=mimeType)
</pre>
<p>
The return content is an <a href="atom.htm">Atom feed</a> containing the version history for that 
resource, sorted with oldest versions first.
</p>

<a name="create"> </a>
<h2>create</h2>
<p>
The create interaction creates a new resource. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url]/[resourcetype] (?$format=mimeType)
</pre>
<p>
The server returns a 201 Created, along with a copy of the newly created resource 
(which might not be the same as that submitted) with the acknowledgement, along with 
a version-aware Location header which contains the new location and id of the created resource:
</p>
<pre>
  Location: [service-url]/[resourcetype]/{@new-id}/history/{@new-vid}
</pre>
<p>
When the payload data is incorrect and cannot be used to create a new resource, the server returns a 400 Bad Request.

Note: If the client wishes to have control over the id of a newly submitted resource, it should use 
the update operation instead.
</p>
<p>
The following resources may require special handling on the server when created (whether directly or as part of a batch):
</p>
<ul>
 <li><a href="provenance.htm">Provenance</a></li>
 <li><a href="patient.htm">Patient</a></li>
</ul>
<p>
Common HTTP Status codes returned on FHIR-related errors (in addition to normal HTTP errors related to security, header and content type negotiation issues):
</p>
<ul>
 <li><b>400 Bad Request</b> - resource could not be parsed</li>
 <li><b>404 Not Found</b> - resource type not supported, or not a FHIR end point</li>
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the proposed resource violated server business rules. This should be accompanied by an <a href="issuereport.htm">Issue</a> resource providing additional detail</li>
</ul>

<a name="search"> </a>
<h2>search</h2>
<p>
This interaction searches a resource type based on some filter criteria. The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/search?parameters (&amp;format=mimeType)
</pre>
<p>
Because of the way that some user agents treat POST requests, POST submissions are also allowed, though the semantics are exactly the 
same as a GET operation. Search operations take a series of parameters that are encoded in the URL or as an x-multi-part-form submission
for a POST. The return content is an <a href="atom.htm">Atom feed </a> containing the results of the search as a list of resources
in a defined order. This specification does not assign any particular meaning to the order of the resources.
</p>
<h3>Search Parameters</h3>
<p>
Each FHIR resource type defines a set of applicable search parameters with their names, types, repeat behaviour, and meanings. 
Parameter values are not case-sensitive. In addition, the following common search parameters apply to all resource types:
</p>
<table class="list">
  <tr><td>$page : <a href="datatypes.htm#integer">integer</a></td><td><i>single</i></td><td>Starting offset of the first record to return in the search set</td></tr>
  <tr><td>$count : <a href="datatypes.htm#integer">integer</a></td><td><i>single</i></td><td>Number of return records requested. The server is not bound to conform</td></tr>
  <tr><td>$id : <a href="datatypes.htm#id">token</a></td><td><i>single</i></td><td>The <a href="xml.htm#metadata">logical resource id</a> associated with the resource (must be supported by all servers)</td></tr>
  <tr><td>$include : <a href="datatypes.htm#id">token</a></td><td><i>union</i></td><td>See below</td></tr>
</table>

<%codelist SearchParamType%>
<h3>Search Parameter Types</h3>
<table class="codes">
 <tr><td>integer</td><td>search parameter must be a simple whole number</td></tr>
 <tr><td>string</td><td>search parameter is a simple string, like a name part (search usually functions on partial matches)</td></tr>
 <tr><td>text</td><td>search parameter is into a long string (i.e. a text filter type search)</td></tr>
 <tr><td>date</td><td>search parameter is onto a date (and should support -before and -after variants). </td></tr>
 <tr><td>token</td><td>search parameter is on a fixed value string (i.e. search has an exact match)</td></tr>
 <tr><td>qtoken</td><td>search parameter is a pair of fixed value strings, namespace and value, separated by a "#". The namespace is usually a uri, such as <a href="terminologies.htm">one of the defined code systems</a> and is optional when searching</td></tr>
</table>

<%codelist SearchRepeatBehavior%>
<h3>Search Parameter Repeat Behaviour</h3>
<table class="codes">
 <tr><td>single</td><td>the search parameter may only be used once</td></tr>
 <tr><td>union</td><td>when the search parameter is used more than once, match resources with any of the values</td></tr>
 <tr><td>intersection</td><td>when the search parameter is used more than once, match resources with all of the values</td></tr>
</table>

<h4>Parameter Chaining</h4>
<p>
Parameters may be "chained" by appending them together separated by "." following a logical path through a graph of related resources.
For instance, given that the resource "LabReport" has a search parameter named <i>patient</i>, which is a reference to a "Patient" resource,
and the Patient resource includes a parameter <i>person</i>, which is a reference to the "Person" resource, and the person resource has a search 
parameter <i>name</i> which searches on patient name, then the search
</p>
<pre>
 LabReports/search?patient.person.name=peter
</pre>
<p>
is a request to return all the lab reports that have a subject whose name includes "peter". 
</p>
<h4>Including other resources in result ($include)</h4>
<p>
Clients may request that the server return additional resources related to the search results, in order to reduce the overall network
query time. A typical case where this is useful is where the client is querying on the patient resource, but for every patient resource
returned, the client will also need the person resource that the patient refers to. The client requests this by providing one or more
$include parameters.
</p>
<p>  
Each $include parameter specifies a path in a URL (as an XPath value):
</p>
<pre>
 LabReports/search?$include=LabReport/patient&amp;$include=Patient/subject
</pre>
<p> 
For each returned resource, the server executes the XPath statement, 
and, if it matches one or more resource references, and it is able to locate the targets, 
appends the target resource to the return result.
Note that $include parameters may be recursive. For instance, a client may request to return all the 
patients associated with a search on 
lab reports, and then to include all the person resources for the patients returned, as shown above.
</p>
<p>
If the $include path matches a general url rather than a resource reference, 
the server may elect to include the target of the url reference in the returned result.
</p>
<h4>Server Conformance</h4>
<p>
Servers have considerable discretion with regards to supporting to search:
</p>
<ul>
 <li>Servers can choose which parameters to support (other than $id below)</li>
 <li>Servers can choose when and where to implement parameter chaining, and when and where they support the $include parameter</li>
 <li>Servers are able to declare additional parameters in their conformance statements</li>
 <li>Servers are not required to enforce case sensitivity on parameter names, though the names are case sensitive (and URLs are generally case-sensitive)</li>
 <li>Servers may choose how many results to return, though the client can use $count as above</li>
</ul>

<p>
If more sophisticated searching is required, a FHIR-based service interface can be defined to enable the workflow and
functionality desired.  
</p>

<a name="updates"> </a>
<h2>updates</h2>
<p>
The updates interaction retrieves a list of the resources of a particular type, ordered by the date of last update in reverse (most recently changed first). The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype] (?$format=mimeType)
</pre>
<p>
The return content is an <a href="atom.htm">Atom feed </a> containing a list of resources, sorted with oldest updates first.  Each resource only appears once, with the most recent version in the list.
</p>
<p>
The updates list can be restricted to a limited period by specifying a $last parameter which contains a full date time with timezone. 
This only includes resources that have changed at or after the given date. Servers must ensure that if a client uses the feed.updated 
date from the last response as the value of the $last parameter, it will not miss any updates. Clients should be aware that 
due to timing imprecision, they may receive notifications of a resource update on the boundary instant more than once. Servers are 
not required to support a a precision finer than by second. Additional parameters can be used to filter the updates list using the search parameters defined by the resource type.
</p>

<a name="validate"> </a>
<h2>validate</h2>
<p>
The validate interaction checks whether the attached content would be acceptable as an 
update to an existing resource. The validation operation may be the first part of a light two-
phase commit process. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  todo: harmonise these with the RLUS REST specification
  POST [service-url]/[resourcetype]/validate/{@id}
</pre>
<p>
The content is first checked against the general specification and against the conformance 
profile that applies to the application. How much checking is performed is at the discretion 
of the server. Then the resource is considered as a proposed update and additional instance 
specific rules such as referential integrity and update logic (including version control) 
are applied as well. The return content has one of the following values:
</p>
<ul>
 <li><b>200 OK</b> - resource passed all validation rules</li>
 <li><b>400 Bad Request</b> - resource could not be parsed or had some validation error itself</li>
 <li><b>490 <a href="http://en.wikipedia.org/wiki/Talk_to_the_hand">Talk to the Hand</a></b> - the resource was valid, but it violates server business rules</li>
</ul>
<p>
Unless the result is 200 OK, the response must include an <a href="issuereport.htm">Issue Report</a> that lists the issues found on validation.
</p>
<p>
The validation operation has complex semantics and rules; see the full discussion of the operation in the OMG REST specification for further details. 
</p>

<a name="conformance"> </a>
<h2>conformance</h2>
<p>
The conformance interaction retrieves the application's conformance statement for the resource. The interaction is performed by an HTTP OPTIONS or a GET operation as shown:
</p>
<pre>
  OPTIONS [service-url] (?$format=mimeType)
  GET [service-url]/metadata (?$format=mimeType)
</pre>
<p>
Applications SHALL return a <a href="conformance.htm">Conformance Resource</a> that specifies which resource types and operations are supported. 
If a 404 Unknown is returned, FHIR is not supported on the nominated service url. The GET operation is defined because not all client libraries 
are able to perform an OPTIONS operation. Additional parameters that are required to be returned with the OPTIONS command are defined in the 
<a href="#hdata">OMG hData RESTful Transport</a> specification.
</p>
<p>
Servers may choose what content to return when they receive a GET operation on the Service Root URL. Generally some page that guides 
human manual interaction with the server would be appropriate.
</p>

<a name="batch"> </a>
<h2>batch</h2>
<p>
The batch interaction submits a set of resources to be updated or created on the server. 
This interaction has two principle uses: to support push-based pub/sub, and to allow 
multiple resources to be updated/created in a single transaction. Multiple different
types of resources may be submitted, including a mix of new and existing resources. 
The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url] (?$format=mimeType)
</pre>
<p>
The content of the post submission is a resource bundle in either <a href="atom.xml">XML</a> or 
<a href="json.htm#json-bundles">JSON</a>. The resources in the bundle are each processed separately
as if they were an individual <a href="#create">create</a> or <a href="#update">update</a> appropriately, along with the normal processing
for each (such as version aware updates). Servers SHALL either accept all resources and return a 200 OK, along with a response bundle, or 
reject all resources and return an HTTP 400 or 500 type response. It is not an error if the 
submitted bundle has no resources in it.
</p>
<p>
When a bundle is submitted in a batch operation, all the resources must be identified. If the 
identity of the resource matches an existing or possible resource location on the server, 
the server should treat this entry as an <a href="#update">update operation</a> (i.e. PUT to the given resource). 
If the identity is not one that the server recognises, the server should treat the operation
as a <a href="#create">create operation</a> (i.e. POST to the given resource manager), and 
create a new identity for the submitted resource. If the server must assign a new identity 
when it accepts the resource, the it must also update any references to that resource in
the same batch as they are processed.
</p>
<p>
In order to allow the client to know how newly created resources are now identified, the 
server must return a bundle containing the same resources in the order that they were submitted.
This allows the client to determine the new identities correctly. 
</p>

<h2>Binary Support</h2>
<p>
FHIR servers can choose to offer support for purely binary resources
at the end point [service-url]/binary. The binary end-point accepts
any kind of resources, and stores them as is, along with the content
type provided by the HTTP headers. 
</p>
<p>
The binary resource functions with the same operations as described
above, except that there is no support for the search operation, nor
can filtering parameters be used on the updates function. The $format 
parameter has no meaning when used with binary resources- they are 
always represented using their original content type.
</p>

<h2>Intermediaries</h2>
<p>
The HTTP protocol may be routed through an HTTP proxy such as 
squid. Such proxies are transparent to the applications, though
implementers should be alert to the effects of rogue caching.
</p>
<p>
Interface engines may also be placed between the consumer and
the provider. These differ from proxies because they actively
alter the content and/or destination of the HTTP exchange and are
not bound the rules that apply to HTTP proxies. Such agents are allowed, 
but must mark the http header to assist with troubleshooting.
</p>
<p>
Any agent that modifies an HTTP request or Response content other
than under the rules for HTTP proxies must add a stamp to the HTTP 
headers like this:
</p>
<pre>
  request-modified-[identity]: [purpose]
  response-modified-[identity]: [purpose]
</pre>
<p>
The identity must be a single token defined by the administrator of the agent
that will sufficiently identify the agent in the context of use. The header
must specify the agent's purpose in modifying the content. End point systems must
not use this header for any purpose. Its aim is to assist with 
system troubleshooting.
</p>

<a name="hdata"> </a>
<h2>OMG hData RESTful Transport</h2>

<p>
This RESTful specification described here is based on the <a href="http://www.omg.org">OMG Health RESTful specification</a> (specific reference to be provided when this is published). 
In this regard, FHIR functions as a Record Format Profile as described in that specification. Note the following significant factors to be aware of:
</p>
<ul>
 <li>FHIR maps the hData sections to resource types, and hData documents to resource instances. There are no subsections, and client systems are not able to create new sections</li>
 <li>The FHIR resource id maps to the hData document name by prepending "@"</li>
 <li>Because clients cannot submit new sections (POST to service URL), POST to the service URL has been re-used for <a href="#batch">the batch operation</a> (difference under review)</li>
 <li>FHIR does not (yet) define a root document. When defined, it will contain information about what the FHIR server has done (as opposed to a conformance statement, which describes what it is capable of doing)</li>
 <li>Note that this specification does not repeat the rules in the hData RESTful Transport concerning the OPTIONS command on the service URL, but these rules (extra headers etc) still apply</li>
</ul>

<%footer%>


<%/maindiv%>    
</body>
</html>