<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
todo:
  register media types for text/xml+fhir application/json+fhir
  replace dependency e-tags with version specific content location. but continue to use etag as well
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>HTTP/RESTful Framework - FHIR v<%version%></title>
    <link rel="Stylesheet" href="fhir.css" type="text/css"/>
    <link rel="Stylesheet" href="fhir-print.css" type="text/css" media="print" />
</head>

<body>
<%sidebar%>

<%maindiv%>
<%pageheader%>
<h1>RESTful HTTP Details</h1>

<p>
In addition to the set of base resources, FHIR also provides a simple RESTful implementation using <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP</a> - 
an implementation of the <a href="http://www.omg.org">OMG Health RESTful specification</a> (specific reference to be provided when this is published). 
Each resource type has the same set of interactions defined that can be used to manage the resources 
in a highly granular fashion. Applications claiming conformance to this framework
claim to be conformant to "RESTful FHIR".
</p>
<p>
Note that in this RESTful framework, transactions are performed directly on the server resource using an 
HTTP request/response. These HTTP calls may be authenticated against a single user account (including 
using <a href="http://www.oauth.org">OAuth</a>), but this arrangement doesn't cater for common transaction metadata such as multiple users, 
responsible party, reasons, consents, etc. that are commonly encountered in healthcare. Instead, 
use of this RESTful implementation assumes that appropriate security and logs are managed by the client (perhaps 
through using <a href="http://wiki.ihe.net/index.php?title=Audit_Trail_and_Node_Authentication">ATNA</a>), and 
that the server trusts the client to maintain these. One implication is that this RESTful framework is 
only suitable for use where such trust relationships exist (e.g. in a single institution) and is not 
suitable where such trust does not exist (e.g. state &amp; national EHR systems and health record 
systems that support disparate systems). Similarly, this simple RESTful interface has no support for 
explicit archiving and similar functions. Use-cases where these kind of features are required should 
consider a <a href="messageheader.htm">messaging</a> or <a href="implementation.htm#SOA">SOA-based approach</a> or 
some kind of profiled REST interface, such as <a href="hdata.htm">hData</a>.
</p>
<p>
The following logical interactions are supported:
</p>
<a name="interactions"></a>
<table class="list"> 
  <tr><td><b>Instance</b></td><td></td></tr>
  <tr><td><a href="#read">read</a></td><td>Read the current state of the resource</td></tr>
  <tr><td><a href="#vread">vread</a></td><td>Read the state of a specific version of the resource</td></tr>
  <tr><td><a href="#update">update</a></td><td>Update an existing resource by its id (or create it if it is new)</td></tr>
  <tr><td><a href="#delete">delete</a></td><td>Delete a resource</td></tr>
  <tr><td><a href="#history">history</a></td><td>Retrieve the update history for the resource</td></tr>
  <tr><td><a href="#validate">validate</a></td><td>Check that the content would be acceptable as an update</td></tr>
  <tr><td colspan="2"><b>Manager</b></td></tr>
  <tr><td><a href="#updates">updates</a></td><td>Get a list of prior updates to resources of this type, optionally with some filter criteria</td></tr>
  <tr><td><a href="#search">search</a></td><td>Search the resource type based on some filter criteria</td></tr>
  <tr><td><a href="#create">create</a></td><td>Create a new resource with a server assigned id</td></tr>
  <tr><td colspan="2"><b>System</b></td></tr>
  <tr><td><a href="#conformance">conformance</a></td><td>Get a conformance statement for support of this resource type</td></tr>
  <tr><td><a href="#batch">batch</a></td><td>Update or create a set of resources</td></tr>
</table>

<p>
Note that while these same logical interactions are defined on all resources, applications are 
not required to implement all of them, except for the conformance statement: applications must 
provide a <a href="conformance.htm">conformance statement</a> that says what interactions are 
supported for any resource types that they support.
</p>

<h2>Service Root URL</h2>
<p>
The Service Root URL is the address where all of the 
resources defined by this interface are found. The Service 
Root URL takes the form of 
</p>
<pre>
http(s)://server[/path]
</pre>
<p>
The optional path may end with a trailing slash or not. Each 
resource type defined in this specification has a manager (or "entity set")
that lives at the address "/[name]" where the
name is the name of the resource type in lower case. 
For instance, the resource manager for the type 
"Patient" will live at:
</p>
<pre>
http://server/path/patient
</pre>
<p>
All the logical operations are defined relative to this service root
URL. Note that this means that given the address of any one FHIR
resource on a system, the correct address for all the other resources 
may be determined. However since application URLs may change and because in some uses of FHIR within internal eco-systems,
local configuration may dictate that the provider of a resource is different
to that claimed by any particular provider or consumer, 
applications may need to replace Service Root URLs.
</p>
<p>
Note: All URLs (and ids that form part of the URL) defined by this specification are case sensitive. 
</p>
<h2>Resource Metadata and Versioning</h2>
<p>
Each resource has an associated set of <a href="xml.htm#metadata">resource metadata elements</a>. These map to the http request and response using the following fields:
</p>
<table class="grid">
  <tr><th>Metadata Item</th><th>HTTP Response Header</th></tr>
  <tr><td>Id</td><td>The Id is represented explicitly in the URL</td></tr>
  <tr><td>Version Id</td><td>The Version Id is represented by the full canonical URL in the content-location header (see <a href="#vread">vread</a> below). 
     The Version Id may also be represented in the http ETag, but the use of ETag is not needed by this specification</td></tr>
  <tr><td>Last Modified Date</td><td>HTTP Last-Modified header</td></tr>
</table>
<p></p>

<h2>Security</h2>
<p>
For this specification, normal HTTP security and authentication rules apply. The Service Root URL will specify 
whether SSL is required. HTTP authentication may be required by the server, possibly including the requirement for 
client certificates. It is a matter of application requirements and local configuration whether all 
interactions run under the account of a trusted system user whether each interaction runs under the 
account of the individual user or whether some other arrangement is required. 
</p>
<p>
<a href="http://oauth.net/">OAuth</a> may be used to provide security. Applications are recommended to use the variants of the OAuth protocol 
that do not require URL parameters, but these may be used if necessary.
</p>
<h2>HTTP Status Codes</h2>
<p>
This specification makes some rules about the use of specific HTTP status codes 
in some particular circumstances where the status codes must map to particular 
states correctly. Other HTTP status codes may be used for other states as appropriate.
Note that some security layers may issue redirects which should not be interpreted
to change the location of the resource itself (a common web programming error). 
</p>
<h2>Content Types and File Extensions</h2>
<p>
The formal mime type for FHIR resources is text/xml+fhir (still to be registered) and SHOULD be use by clients and servers.
Servers are required to support the XML format of the resources defined in this specification, but may support other
alternatives, including the informative <a href="xml.htm#json">JSON</a> representation. Servers must support the 
content-type negotiation support described by the HTTP specification, but in order to support various implementation
limitations, may choose to support the (?format=) parameter to specify alternative return formats by their mime types.
The format parameter may have the value "xml", "html" or "json", or a mime type (including text/xml and application/json). 
For the format parameter, the mime types text/xml &amp; text/xml+fhir must be interpreted to mean the normative XML format
defined by FHIR and application/json must be interpreted to mean the informative <a href="json.htm">JSON format</a>.
</p>

<a name="read"> </a>
<h2>read</h2>
<p>
The read interaction accesses the current contents of a resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id} (?format=mimeType) 
</pre>
<p>
This returns a single instance with the content specified for the resource type.
This url may be accessed by a browser. The logical id is preceded by a "@" to make parsing the url easier.
The possible values for the id itself are described in the <a href="datatypes.htm#id">id type</a>.
Servers are required to return a content-location header with the response which is the full version 
specific url (see vread below) and a Last-Modified header.
</p>
<a name="vread"> </a>
<h2>vread</h2>
<p>
The vread interaction preforms a version specific read of the resource. The interaction
is performed by an HTTP GET operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history/{@vid} (?format=mimeType)
</pre>
<p>
This returns a single instance with the content specified for the resource type.
Servers may return a content-location header with the response which is the url 
requested and a Last-Modified header.
</p>
<p>
The version id is an opaque identifier that conforms to the same format requirements as 
a resource id. The id may have been found by performing a history operation (see below), by recording the 
version id from a content location returned from a read or from a version specific reference in a 
content model. The vread interaction should succeed even after a resource is deleted as long as a 
correct version identifier is provided. 
</p>
<p>
Servers SHOULD support a version specific retrieval of the current version of the 
resource even if they are unable to support access to previous versions. 
</p>
<a name="update"> </a>
<h2>update</h2>
<p>
The update interaction changes an existing resource or creates a new resource if it doesn't already exist. 
The update interaction is performed by an HTTP PUT operation as shown:
</p>
<pre>
  PUT [service-url]/[resourcetype]/{@id} (?format=mimeType)
</pre>
<p>
If the operation is successful, the server must return 200 OK, along with a copy of the 
newly updated resource (which might not be the same as that submitted) with the response, along 
with a Last-Modified header, and a Content-Location header that refers to the version created by the 
updated operation.
</p>
<p>
Servers are permitted to reject update operations because of integrity concerns or business 
rules implemented on the server, and return HTTP status codes accordingly. 
</p>
<p>
In particular, servers may choose to implement version-aware updates, where the only updates that are 
accepted quote the current version of the resource. In this case, the client must submit the currently 
correct version specific URL in the Content-Location in the PUT request. If the value is incorrect, 
the server SHALL return a 412 Preconditions failed response. Clients SHOULD submit a proper Content-Location 
header and SHALL correctly understand a 412 response as an update conflict. 
</p>

<a name="delete"> </a>
<h2>delete</h2>
<p>
The delete interaction removes an existing resource. The interaction
is performed by an HTTP DELETE operation as shown:
</p>
<pre>
  DELETE [service-url]/[resourcetype]/{@id} 
</pre>
<p>
A delete operation means that <a href="#read">non-version specific reads</a> of a resource 
return a 410 error and that the resource is no longer found through search operations. If a server 
refuses to delete resources of that type on principle, then it should return the status code 
405 method not allowed. If the server refuses to delete a resource because of reasons specific 
to that resource, such as referential integrity, it should return the status code 409 Conflict.
Resources may be undeleted by PUTting an update to them subsequent to the deletion. 
</p>
<p>
Many resources have a status element that overlaps with the idea of deletion. Each resource type
defines what the semantics of the deletion operations are. If no documentation is provided, the 
deletion operation should be understood as deleting the record of the resource, with nothing
about the state of the real-world corresponding resource implied.
</p>
<a name="history"> </a>
<h2>history</h2>
<p>
The history interaction retrieves the history of the resource. The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/{@id}/history (?format=mimeType)
</pre>
<p>
The return content is an <a href="atom.htm">Atom feed</a> containing the version history for that 
resource, sorted with oldest versions first. ToDo: how deletions are represented.
</p>


<a name="validate"> </a>
<h2>validate</h2>
<p>
The validate interaction checks whether the attached content would be acceptable as an 
update to an existing resource. The validation operation may be the first part of a light two-
phase commit process. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  todo: harmonise these with the RLUS REST specification
  POST [service-url]/[resourcetype]/validate/{@id}
</pre>
<p>
The content is first checked against the general specification and against the conformance 
profile that applies to the application. How much checking is performed is at the discretion 
of the server. Then the resource is considered as a proposed update and additional instance 
specific rules such as referential integrity and update logic are applied as well.
The return content has status 200 OK if the content validates ok or 409 Conflict,
with the following content:
</p>
<pre>
 &lt;<b>validation</b> xmlns="http://hl7.org/fhir">
   &lt;<b>error</b> <a href="xml.htm#Control" class="cf">mand</a> <font color="darkgreen">type="<a href="datatypes.htm#string">string</a>"</font>&gt;<font color="navy">General error message</font>&lt;/error&gt;  
   &lt;<b>messages</b> <font color="darkgreen">type="list"</font>>   <font color="Gray">&lt;!-- Zero+ --&gt;</font>
     &lt;<b>message</b>&gt;
       &lt;<b>path</b> <a href="xml.htm#Control" class="cf">opt</a> <font color="darkgreen">type="string"</font><font color="navy">xpath to the issue</font>&lt;/path&gt;
       &lt;<b>error</b> <a href="xml.htm#Control" class="cf">mand</a> <font color="darkgreen">type="string"</font>&gt;<font color="navy">Description of the problem</font>&lt;/error&gt;
     &lt;/message&gt;
   &lt;messages&gt;
 &lt;/validation&gt;
</pre>
<p>
The validation operation has complex semantics and rules. Implementers wishing to use this operation
should consult the full discussion of the operation in the OMG REST specification. 
</p>

<a name="updates"> </a>
<h2>updates</h2>
<p>
The updates interaction retrieves a list of the resources of a particular type, ordered by the date of last update in reverse (most recently changed first). The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype] (?format=mimeType)
</pre>
<p>
The return content is an <a href="atom.htm">Atom feed </a> containing a list of resources, sorted with oldest updates first.  Each resource only appears once, with the most recent version in the list.
</p>
<p>
The updates list can be restricted to a limited period by the Last-Modified header. Additional parameters can be used to filter the updates list using the search parameters defined by the resource type.
</p>

<a name="search"> </a>
<h2>search</h2>
<p>
This interaction searches a resource type based on some filter criteria. The interaction is performed by an HTTP Get operation as shown:
</p>
<pre>
  GET [service-url]/[resourcetype]/search?parameters (&amp;format=mimeType)
</pre>
<p>
Because of the way that some user agents treat POST requests, POST submissions are also allowed, though the semantics are exactly the 
same as a GET operation. Search operations take a series of parameters that are encoded in the URL or as an x-multi-part-form submission
for a POST. The return content is an <a href="atom.htm">Atom feed </a> containing the results of the search as a list of resources
in a defined order. This specification does not assign any particular meaning to the order of the resources.
</p>
<h3>Search Parameters</h3>
<p>
Each FHIR resource type defines a set of applicable search parameters with their names, types, repeat behaviour, and meanings. 
Parameter values are not case-sensitive. In addition, the following common search parameters apply to all resource types:
</p>
<table class="list">
  <tr><td>$page : <a href="datatypes.htm#integer">integer</a></td><td><i>single</i></td><td>Starting offset of the first record to return in the search set</td></tr>
  <tr><td>$count : <a href="datatypes.htm#integer">integer</a></td><td><i>single</i></td><td>Number of return records requested. The server is not bound to conform</td></tr>
  <tr><td>$id : <a href="datatypes.htm#id">token</a></td><td><i>single</i></td><td>The <a href="xml.htm#metadata">logical resource id</a> associated with the resource (must be supported by all servers)</td></tr>
  <tr><td>$include : <a href="datatypes.htm#id">token</a></td><td><i>union</i></td><td>See below</td></tr>
</table>

<%codelist SearchParamType%>
<h3>Search Parameter Types</h3>
<table class="codes">
 <tr><td>integer</td><td>search parameter must be a simple whole number</td></tr>
 <tr><td>string</td><td>search parameter is a simple string, like a name part (search usually functions on partial matches)</td></tr>
 <tr><td>text</td><td>search parameter is into a long string (i.e. a text filter type search)</td></tr>
 <tr><td>date</td><td>search parameter is onto a date (and should support -before and -after variants). </td></tr>
 <tr><td>token</td><td>search parameter is on a fixed value string (i.e. search has an exact match)</td></tr>
 <tr><td>qtoken</td><td>search parameter is a pair of fixed value strings, namespace and value, separated by a "#". The namespace is usually a uri, such as <a href="terminologies.htm">one of the defined code systems</a> and is optional when searching</td></tr>
</table>

<%codelist SearchRepeatBehavior%>
<h3>Search Parameter Repeat Behaviour</h3>
<table class="codes">
 <tr><td>single</td><td>the search parameter may only be used once</td></tr>
 <tr><td>union</td><td>when the search parameter is used more than once, match resources with any of the values</td></tr>
 <tr><td>intersection</td><td>when the search parameter is used more than once, match resources with all of the values</td></tr>
</table>

<h4>Parameter Chaining</h4>
<p>
Parameters may be "chained" by appending them together separated by "." following a logical path through a graph of related resources.
For instance, given that the resource "LabReport" has a search parameter named <i>patient</i>, which is a reference to a "Patient" resource,
and the Patient resource includes a parameter <i>person</i>, which is a reference to the "Person" resource, and the person resource has a search 
parameter <i>name</i> which searches on patient name, then the search
</p>
<pre>
 LabReports/search?patient.person.name=peter
</pre>
<p>
is a request to return all the lab reports that have a subject whose name includes "peter". 
</p>
<h4>Including other parameters ($include)</h4>
<p>
Clients may request that the server return additional resources related to the search results, in order to reduce the overall network
query time. A typical case where this is useful is where the client is querying on the patient resource, but for every patient resource
returned, the client will also need the person resource that the patient refers to. The client requests this by providing one or more
$include parameters.
</p>
<p>  
Each $include parameter specifies a path in a URL (as an XPath value):
</p>
<pre>
 LabReports/search?$include=LabReport/patient&amp;$include=Patient/subject
</pre>
<p> 
For each returned resource, the server executes the XPath statement, 
and, if it matches one or more resource references, and it is able to locate the targets, appends the target resource to the return result.
Note that $include parameters may be recursive. For instance, a client may request to return all the patients associated with a search on 
lab reports, and then to include all the person resources for the patients returned, as shown above.
</p>
<p>
If the $include path matches an general url rather than a resource reference, the server may elect to include the target of the url reference
in the returned result.
</p>
<h4>Server Conformance</h4>
<p>
Servers have considerable discretion with regards to supporting to search:
</p>
<ul>
 <li>Servers can choose which parameters to support (other than $id below)</li>
 <li>Servers can choose when and where to implement parameter chaining, and when and where they support the $include parameter</li>
 <li>Servers are able to declare additional parameters in their conformance statements</li>
 <li>Servers are not required to enforce case sensitivity on parameter names, though the names are case sensitive (and URLs are generally case-sensitive)</li>
 <li>Servers may choose how many results to return, though the client can use $count as above</li>
</ul>

<p>
If more sophisticated searching is required, a FHIR-based service interface can be defined to enable the workflow and
functionality desired.  
</p>

<a name="create"> </a>
<h2>create</h2>
<p>
The create interaction creates a new resource. The interaction is performed by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url]/[resourcetype] (?format=mimeType)
</pre>
<p>
The server returns a 201 Created, along with a copy of the newly created resource 
(which might not be the same as that submitted) with the acknowledgement, along with 
a Location: header which also contains the new location and id of the created resource:
</p>
<pre>
 Location: [service-url]/[resourcetype]/{new-id} version aware.... 
</pre>
<p>
If the client wishes to specify the id of the submitted resource, then it should use 
the update operation instead. 
</p>


<a name="conformance"> </a>
<h2>conformance</h2>
<p>
The conformance interaction retrieves the application's conformance statement for the resource. The interaction is performed by an HTTP OPTIONS or a GET operation as shown:
</p>
<pre>
  OPTIONS [service-url] (?format=mimeType)
  GET [service-url]/metadata (?format=mimeType)
</pre>
<p>
Applications SHALL return a <a href="conformance.htm">Conformance Resource</a> that specifies which resource types and operations are supported. 
If a 404 Unknown is returned, FHIR is not supported on the nominated service url. The GET operation is defined because not all client libraries 
are able to perform an OPTIONS operation.
</p>
<p>
Servers may choose what content to return when they receive a GET operation on the Service Root URL. Generally some page that guides 
human manual interaction with the server would be appropriate.
</p>

<a name="batch"> </a>
<h2>batch</h2>
<p>
The batch interaction submits a set of resources to be updated or created on the server. 
This interaction has two principle uses: to support push-based pub/sub, and to allow 
multiple resources to be updated in a single transaction. The interaction is performed 
by an HTTP POST operation as shown:
</p>
<pre>
  POST [service-url] (?format=mimeType)
</pre>
<p>
The content of the post submission is a resource bundle in either <a href="atom.xml">XML</a> or <a href="json.htm#json-bundles">JSON</a>. 
Servers SHALL accept all resources and return a 204 No Content, or reject all resources and return an HTTP 400 or 500 type response. 
</p>
<p>
If the resources are not identified as resource belonging to the server to which the bundle is submitted, the server can choose how to <a href="implementation.htm#identity">handle 
the identification of the resources</a>, though it is required to maintain internal resource references in the submitted contents. 
</p>


<h2>Intermediaries</h2>
<p>
The HTTP protocol may be routed through an HTTP proxy such as 
squid. Such proxies are transparent to the applications, though
implementers should be alert to the effects of rogue caching.
</p>
<p>
Interface engines may also be placed between the consumer and
the provider. These differ from proxies because they actively
alter the content and/or destination of the HTTP exchange and are
not bound the rules that apply to HTTP proxies. Such agents are allowed, 
but must mark the http header to assist with troubleshooting.
</p>
<p>
Any agent that modifies an HTTP request or Response content other
than under the rules for HTTP proxies must add a stamp to the HTTP 
headers like this:
</p>
<pre>
  request-modified-[identity]: [purpose]
  response-modified-[identity]: [purpose]
</pre>
<p>
The identity must be a single token defined by the administrator of the agent
that will sufficiently identify the agent in the context of use. The header
must specify the agent's purpose in modifying the content. End point systems must
not use this header for any purpose. Its aim is to assist with 
system troubleshooting.
</p>


<%footer%>


<%/maindiv%>    
</body>
</html>